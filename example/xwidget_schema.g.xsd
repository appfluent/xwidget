<?xml version="1.0" encoding="UTF-8"?>

<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="http://www.appfluent.us/xwidget"
    targetNamespace="http://www.appfluent.us/xwidget">

    <!-- simple types -->

    <xs:simpleType name="builderReturnTypeAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="Widget"/>
                    <xs:enumeration value="Widget?"/>
                    <xs:enumeration value="List:Widget"/>
                    <xs:enumeration value="List:PopupMenuEntry"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="expressionAttributeType">
        <xs:restriction base="xs:string">
            <xs:pattern value="\$\{.*\}" />
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="dependenciesScopeAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="copy"/>
                    <xs:enumeration value="inherit"/>
                    <xs:enumeration value="new"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="boolAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="true"/>
                    <xs:enumeration value="false"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="integerAttributeType">
        <xs:union memberTypes="expressionAttributeType xs:integer"/>
    </xs:simpleType>

    <xs:simpleType name="AlignmentAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="topLeft"/>
                    <xs:enumeration value="topCenter"/>
                    <xs:enumeration value="topRight"/>
                    <xs:enumeration value="centerLeft"/>
                    <xs:enumeration value="center"/>
                    <xs:enumeration value="centerRight"/>
                    <xs:enumeration value="bottomLeft"/>
                    <xs:enumeration value="bottomCenter"/>
                    <xs:enumeration value="bottomRight"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="AlignmentDirectionalAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="topStart"/>
                    <xs:enumeration value="topCenter"/>
                    <xs:enumeration value="topEnd"/>
                    <xs:enumeration value="centerStart"/>
                    <xs:enumeration value="center"/>
                    <xs:enumeration value="centerEnd"/>
                    <xs:enumeration value="bottomStart"/>
                    <xs:enumeration value="bottomCenter"/>
                    <xs:enumeration value="bottomEnd"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="AlignmentGeometryAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="topLeft"/>
                    <xs:enumeration value="topStart"/>
                    <xs:enumeration value="topCenter"/>
                    <xs:enumeration value="topEnd"/>
                    <xs:enumeration value="topRight"/>
                    <xs:enumeration value="centerLeft"/>
                    <xs:enumeration value="centerStart"/>
                    <xs:enumeration value="center"/>
                    <xs:enumeration value="centerEnd"/>
                    <xs:enumeration value="centerRight"/>
                    <xs:enumeration value="bottomLeft"/>
                    <xs:enumeration value="bottomStart"/>
                    <xs:enumeration value="bottomCenter"/>
                    <xs:enumeration value="bottomEnd"/>
                    <xs:enumeration value="bottomRight"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="BuildExecutionAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="async"/>
                    <xs:enumeration value="sync"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="CurvesAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="bounceIn"/>
                    <xs:enumeration value="bounceInOut"/>
                    <xs:enumeration value="bounceOut"/>
                    <xs:enumeration value="decelerate"/>
                    <xs:enumeration value="ease"/>
                    <xs:enumeration value="easeIn"/>
                    <xs:enumeration value="easeInBack"/>
                    <xs:enumeration value="easeInCirc"/>
                    <xs:enumeration value="easeInCubic"/>
                    <xs:enumeration value="easeInExpo"/>
                    <xs:enumeration value="easeInOut"/>
                    <xs:enumeration value="easeInOutBack"/>
                    <xs:enumeration value="easeInOutCirc"/>
                    <xs:enumeration value="easeInOutCubic"/>
                    <xs:enumeration value="easeInOutCubicEmphasized"/>
                    <xs:enumeration value="easeInOutExpo"/>
                    <xs:enumeration value="easeInOutQuad"/>
                    <xs:enumeration value="easeInOutQuart"/>
                    <xs:enumeration value="easeInOutQuint"/>
                    <xs:enumeration value="easeInOutSine"/>
                    <xs:enumeration value="easeInQuad"/>
                    <xs:enumeration value="easeInQuart"/>
                    <xs:enumeration value="easeInQuint"/>
                    <xs:enumeration value="easeInSine"/>
                    <xs:enumeration value="easeInToLinear"/>
                    <xs:enumeration value="easeOut"/>
                    <xs:enumeration value="easeOutBack"/>
                    <xs:enumeration value="easeOutCirc"/>
                    <xs:enumeration value="easeOutCubic"/>
                    <xs:enumeration value="easeOutExpo"/>
                    <xs:enumeration value="easeOutQuad"/>
                    <xs:enumeration value="easeOutQuart"/>
                    <xs:enumeration value="easeOutQuint"/>
                    <xs:enumeration value="easeOutSine"/>
                    <xs:enumeration value="elasticIn"/>
                    <xs:enumeration value="elasticInOut"/>
                    <xs:enumeration value="elasticOut"/>
                    <xs:enumeration value="fastLinearToSlowEaseIn"/>
                    <xs:enumeration value="fastOutSlowIn"/>
                    <xs:enumeration value="linear"/>
                    <xs:enumeration value="linearToEaseOut"/>
                    <xs:enumeration value="slowMiddle"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="FontWeightAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="100"/>
                    <xs:enumeration value="200"/>
                    <xs:enumeration value="300"/>
                    <xs:enumeration value="400"/>
                    <xs:enumeration value="500"/>
                    <xs:enumeration value="600"/>
                    <xs:enumeration value="700"/>
                    <xs:enumeration value="800"/>
                    <xs:enumeration value="900"/>
                    <xs:enumeration value="thin"/>
                    <xs:enumeration value="extraLight"/>
                    <xs:enumeration value="light"/>
                    <xs:enumeration value="normal"/>
                    <xs:enumeration value="medium"/>
                    <xs:enumeration value="semiBold"/>
                    <xs:enumeration value="bold"/>
                    <xs:enumeration value="extraBold"/>
                    <xs:enumeration value="black"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="InputBorderAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="none"/>
                    <xs:enumeration value="outline"/>
                    <xs:enumeration value="underline"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="ListOperationAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="add"/>
                    <xs:enumeration value="spread"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="TextDecorationAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="lineThrough"/>
                    <xs:enumeration value="overline"/>
                    <xs:enumeration value="underline"/>
                    <xs:enumeration value="none"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="TextInputTypeAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="datetime"/>
                    <xs:enumeration value="emailAddress"/>
                    <xs:enumeration value="multiline"/>
                    <xs:enumeration value="name"/>
                    <xs:enumeration value="none"/>
                    <xs:enumeration value="number"/>
                    <xs:enumeration value="phone"/>
                    <xs:enumeration value="streetAddress"/>
                    <xs:enumeration value="text"/>
                    <xs:enumeration value="url"/>
                    <xs:enumeration value="visiblePassword"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="VariableDisposalAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="none"/>
                    <xs:enumeration value="byOwner"/>
                    <xs:enumeration value="byLastListener"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <!-- generated enum types -->

    <xs:simpleType name="ClipAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="none"/>
                    <xs:enumeration value="hardEdge"/>
                    <xs:enumeration value="antiAlias"/>
                    <xs:enumeration value="antiAliasWithSaveLayer"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="BrightnessAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="dark"/>
                    <xs:enumeration value="light"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="DynamicSchemeVariantAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="tonalSpot"/>
                    <xs:enumeration value="fidelity"/>
                    <xs:enumeration value="monochrome"/>
                    <xs:enumeration value="neutral"/>
                    <xs:enumeration value="vibrant"/>
                    <xs:enumeration value="expressive"/>
                    <xs:enumeration value="content"/>
                    <xs:enumeration value="rainbow"/>
                    <xs:enumeration value="fruitSalad"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="MainAxisAlignmentAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="start"/>
                    <xs:enumeration value="end"/>
                    <xs:enumeration value="center"/>
                    <xs:enumeration value="spaceBetween"/>
                    <xs:enumeration value="spaceAround"/>
                    <xs:enumeration value="spaceEvenly"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="MainAxisSizeAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="min"/>
                    <xs:enumeration value="max"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="CrossAxisAlignmentAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="start"/>
                    <xs:enumeration value="end"/>
                    <xs:enumeration value="center"/>
                    <xs:enumeration value="stretch"/>
                    <xs:enumeration value="baseline"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="TextDirectionAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="rtl"/>
                    <xs:enumeration value="ltr"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="VerticalDirectionAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="up"/>
                    <xs:enumeration value="down"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="TextBaselineAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="alphabetic"/>
                    <xs:enumeration value="ideographic"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="MaterialTapTargetSizeAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="padded"/>
                    <xs:enumeration value="shrinkWrap"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="BlendModeAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="clear"/>
                    <xs:enumeration value="src"/>
                    <xs:enumeration value="dst"/>
                    <xs:enumeration value="srcOver"/>
                    <xs:enumeration value="dstOver"/>
                    <xs:enumeration value="srcIn"/>
                    <xs:enumeration value="dstIn"/>
                    <xs:enumeration value="srcOut"/>
                    <xs:enumeration value="dstOut"/>
                    <xs:enumeration value="srcATop"/>
                    <xs:enumeration value="dstATop"/>
                    <xs:enumeration value="xor"/>
                    <xs:enumeration value="plus"/>
                    <xs:enumeration value="modulate"/>
                    <xs:enumeration value="screen"/>
                    <xs:enumeration value="overlay"/>
                    <xs:enumeration value="darken"/>
                    <xs:enumeration value="lighten"/>
                    <xs:enumeration value="colorDodge"/>
                    <xs:enumeration value="colorBurn"/>
                    <xs:enumeration value="hardLight"/>
                    <xs:enumeration value="softLight"/>
                    <xs:enumeration value="difference"/>
                    <xs:enumeration value="exclusion"/>
                    <xs:enumeration value="multiply"/>
                    <xs:enumeration value="hue"/>
                    <xs:enumeration value="saturation"/>
                    <xs:enumeration value="color"/>
                    <xs:enumeration value="luminosity"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="ThemeModeAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="system"/>
                    <xs:enumeration value="light"/>
                    <xs:enumeration value="dark"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="DragStartBehaviorAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="down"/>
                    <xs:enumeration value="start"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="TextAlignAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="left"/>
                    <xs:enumeration value="right"/>
                    <xs:enumeration value="center"/>
                    <xs:enumeration value="justify"/>
                    <xs:enumeration value="start"/>
                    <xs:enumeration value="end"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="TextOverflowAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="clip"/>
                    <xs:enumeration value="fade"/>
                    <xs:enumeration value="ellipsis"/>
                    <xs:enumeration value="visible"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="TextWidthBasisAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="parent"/>
                    <xs:enumeration value="longestLine"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="FontStyleAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="normal"/>
                    <xs:enumeration value="italic"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="TextLeadingDistributionAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="proportional"/>
                    <xs:enumeration value="even"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="TextDecorationStyleAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="solid"/>
                    <xs:enumeration value="double"/>
                    <xs:enumeration value="dotted"/>
                    <xs:enumeration value="dashed"/>
                    <xs:enumeration value="wavy"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>

    <xs:simpleType name="TargetPlatformAttributeType">
        <xs:union memberTypes="expressionAttributeType">
            <xs:simpleType>
                <xs:restriction base="xs:string">
                    <xs:enumeration value="android"/>
                    <xs:enumeration value="fuchsia"/>
                    <xs:enumeration value="iOS"/>
                    <xs:enumeration value="linux"/>
                    <xs:enumeration value="macOS"/>
                    <xs:enumeration value="windows"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:union>
    </xs:simpleType>


    <!-- complex types -->

    <xs:complexType name="listItemType">
        <xs:sequence>
            <xs:any namespace="##targetNamespace" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="value" use="required"/>
        <xs:attribute name="visible" type="boolAttributeType"/>
    </xs:complexType>

    <xs:complexType name="mapEntryType">
        <xs:sequence>
            <xs:any namespace="##targetNamespace" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="key" use="required"/>
        <xs:attribute name="value"/>
        <xs:attribute name="visible" type="boolAttributeType"/>
    </xs:complexType>

    <xs:complexType name="objectType" mixed="true">
        <xs:sequence>
            <xs:any namespace="##targetNamespace" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="for" type="xs:string"/>
        <xs:attribute name="visible" type="boolAttributeType"/>
    </xs:complexType>

    <xs:complexType name="paramType">
        <xs:sequence>
            <xs:any namespace="##targetNamespace" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name" use="required"/>
        <xs:attribute name="value"/>
        <xs:attribute name="visible" type="boolAttributeType"/>
    </xs:complexType>

    <!-- built-in tag elements -->

    <xs:element name="builder">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType >
            <xs:sequence>
                <xs:any namespace="##targetNamespace" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="for" type="xs:string"/>
            <xs:attribute name="vars" type="xs:string"/>
            <xs:attribute name="returnType" type="builderReturnTypeAttributeType"/>
            <xs:attribute name="dependenciesScope" type="dependenciesScopeAttributeType"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="callback">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType >
            <xs:attribute name="for" type="xs:string" use="required"/>
            <xs:attribute name="action" type="xs:string" use="required"/>
            <xs:attribute name="returnVar" type="xs:string"/>
            <xs:attribute name="vars" type="xs:string"/>
            <xs:attribute name="dependenciesScope" type="dependenciesScopeAttributeType"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="debug">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="message" type="xs:string" use="required"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="forEach">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:any namespace="##targetNamespace" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="var" type="xs:string" use="required"/>
            <xs:attribute name="indexVar" type="xs:string"/>
            <xs:attribute name="items" type="xs:string" use="required"/>
            <xs:attribute name="groupSize" type="integerAttributeType"/>
            <xs:attribute name="dependenciesScope" type="dependenciesScopeAttributeType"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="forLoop">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:any namespace="##targetNamespace" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="var" type="xs:string" use="required"/>
            <xs:attribute name="begin" type="integerAttributeType"/>
            <xs:attribute name="end" type="integerAttributeType"/>
            <xs:attribute name="step" type="integerAttributeType"/>
            <xs:attribute name="dependenciesScope" type="dependenciesScopeAttributeType"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="fragment">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="forEach" form="qualified">
                    <xs:complexType>
                        <xs:sequence>
                            <xs:element name="param" type="paramType" form="qualified"/>
                        </xs:sequence>
                        <xs:attribute name="var" type="xs:string" use="required"/>
                        <xs:attribute name="indexVar" type="xs:string"/>
                        <xs:attribute name="items" type="xs:string" use="required"/>
                        <xs:attribute name="start" type="integerAttributeType"/>
                        <xs:attribute name="end" type="integerAttributeType"/>
                        <xs:attribute name="dependenciesScope" type="dependenciesScopeAttributeType"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="if" form="qualified">
                    <xs:complexType>
                        <xs:choice maxOccurs="unbounded">
                            <xs:element name="param" type="paramType" form="qualified"/>
                        </xs:choice>
                        <xs:attribute name="test" type="xs:string" use="required"/>
                    </xs:complexType>
                </xs:element>
                <xs:element name="param" type="paramType" form="qualified"/>
            </xs:choice>
            <xs:attribute name="for" type="xs:string"/>
            <xs:attribute name="name" type="xs:string" use="required"/>
            <xs:attribute name="visible" type="boolAttributeType"/>
            <xs:attribute name="dependenciesScope" type="dependenciesScopeAttributeType"/>
            <xs:anyAttribute processContents="lax"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="if">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:any namespace="##targetNamespace" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="test" type="xs:string" use="required"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="else">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:any namespace="##targetNamespace" minOccurs="1" maxOccurs="unbounded"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <xs:element name="var">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:attribute name="name" type="xs:string" use="required"/>
            <xs:attribute name="value" type="xs:string" use="required"/>
        </xs:complexType>
    </xs:element>

    <!-- built-in inflater elements -->

    <xs:element name="Controller">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key"/>
                    <xs:attribute name="name"/>
                    <xs:attribute name="errorWidget"/>
                    <xs:attribute name="progressWidget"/>
                    <xs:attribute name="options"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="DynamicBuilder">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key"/>
                    <xs:attribute name="builder"/>
                    <xs:attribute name="errorWidget"/>
                    <xs:attribute name="progressWidget"/>
                    <xs:attribute name="initializer"/>
                    <xs:attribute name="initValue"/>
                    <xs:attribute name="disposeOfDependencies" type="boolAttributeType"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="EventListener">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key"/>
                    <xs:attribute name="event"/>
                    <xs:attribute name="onEvent"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="List">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:sequence>
                        <xs:element name="Item" form="qualified" type="listItemType" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="innerLists" type="ListOperationAttributeType"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="Map">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element name="Entry" form="qualified" type="mapEntryType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="for" type="xs:string"/>
            <xs:attribute name="visible" type="boolAttributeType"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="MediaQuery">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key"/>
                    <xs:attribute name="varName" type="xs:string"/>
                    <xs:attribute name="smallMaxWidth" type="integerAttributeType"/>
                    <xs:attribute name="mediumMaxWidth" type="integerAttributeType"/>
                    <xs:attribute name="dependenciesScope" type="dependenciesScopeAttributeType"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ValueListener">
        <xs:annotation>
            <xs:documentation xml:lang="en">
            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key"/>
                    <xs:attribute name="varName"/>
                    <xs:attribute name="varDisposal" type="VariableDisposalAttributeType"/>
                    <xs:attribute name="initialValue"/>
                    <xs:attribute name="defaultValue"/>
                    <xs:attribute name="onChange"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <!-- generated inflater elements -->

    <xs:element name="AppBar">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a Material Design app bar.</p><br/>
<p>If [elevation] is specified, it must be non-negative.</p><br/>
<p>Typically used in the [Scaffold.appBar] property.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="leading">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.leading}
A widget to display before the toolbar's [title].</p><br/>
<p>Typically the [leading] widget is an [Icon] or an [IconButton].</p><br/>
<p>Becomes the leading component of the [NavigationToolbar] built
by this widget. The [leading] widget's width and height are constrained to
be no bigger than [leadingWidth] and [toolbarHeight] respectively.</p><br/>
<p>If this is null and [automaticallyImplyLeading] is set to true, the
[AppBar] will imply an appropriate widget. For example, if the [AppBar] is
in a [Scaffold] that also has a [Drawer], the [Scaffold] will fill this
widget with an [IconButton] that opens the drawer (using [Icons.menu]). If
there's no [Drawer] and the parent [Navigator] can go back, the [AppBar]
will use a [BackButton] that calls [Navigator.maybePop].
{@endtemplate}</p><br/>
<p>{@tool snippet}</p><br/>
<p>The following code shows how the drawer button could be manually specified
instead of relying on [automaticallyImplyLeading]:</p><br/>
<pre><code class="language-dart">AppBar(
  leading: Builder(
    builder: (BuildContext context) {
      return IconButton(
        icon: const Icon(Icons.menu),
        onPressed: () { Scaffold.of(context).openDrawer(); },
        tooltip: MaterialLocalizations.of(context).openAppDrawerTooltip,
      );
    },
  ),
)
</code></pre>
<p>{@end-tool}</p><br/>
<p>The [Builder] is used in this example to ensure that the <code>context</code> refers
to that part of the subtree. That way this code snippet can be used even
inside the very code that is creating the [Scaffold] (in which case,
without the [Builder], the <code>context</code> wouldn't be able to see the
[Scaffold], since it would refer to an ancestor of that widget).</p><br/>
<p>See also:</p><br/>
<ul>
<li>[Scaffold.appBar], in which an [AppBar] is usually placed.</li>
<li>[Scaffold.drawer], in which the [Drawer] is usually placed.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="automaticallyImplyLeading" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.automaticallyImplyLeading}
Controls whether we should try to imply the leading widget if null.</p><br/>
<p>If true and [AppBar.leading] is null, automatically try to deduce what the leading
widget should be. If false and [AppBar.leading] is null, leading space is given to [AppBar.title].
If leading widget is not null, this parameter has no effect.
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="title">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.title}
The primary widget displayed in the app bar.</p><br/>
<p>Becomes the middle component of the [NavigationToolbar] built by this widget.</p><br/>
<p>Typically a [Text] widget that contains a description of the current
contents of the app.
{@endtemplate}</p><br/>
<p>The [title]'s width is constrained to fit within the remaining space
between the toolbar's [leading] and [actions] widgets. Its height is
<em>not</em> constrained. The [title] is vertically centered and clipped to fit
within the toolbar, whose height is [toolbarHeight]. Typically this
isn't noticeable because a simple [Text] [title] will fit within the
toolbar by default. On the other hand, it is noticeable when a
widget with an intrinsic height that is greater than [toolbarHeight]
is used as the [title]. For example, when the height of an Image used
as the [title] exceeds [toolbarHeight], it will be centered and
clipped (top and bottom), which may be undesirable. In cases like this
the height of the [title] widget can be constrained. For example:</p><br/>
<pre><code class="language-dart">MaterialApp(
  home: Scaffold(
    appBar: AppBar(
      title: SizedBox(
        height: _myToolbarHeight,
        child: Image.asset(_logoAsset),
      ),
      toolbarHeight: _myToolbarHeight,
    ),
  ),
)
</code></pre>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="actions">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.actions}
A list of Widgets to display in a row after the [title] widget.</p><br/>
<p>Typically these widgets are [IconButton]s representing common operations.
For less common operations, consider using a [PopupMenuButton] as the
last action.</p><br/>
<p>The [actions] become the trailing component of the [NavigationToolbar] built
by this widget. The height of each action is constrained to be no bigger
than the [toolbarHeight].</p><br/>
<p>To avoid having the last action covered by the debug banner, you may want
to set the [MaterialApp.debugShowCheckedModeBanner] to false.
{@endtemplate}</p><br/>
<p>{@tool snippet}</p><br/>
<pre><code class="language-dart">Scaffold(
  body: CustomScrollView(
    primary: true,
    slivers: &lt;Widget&gt;[
      SliverAppBar(
        title: const Text('Hello World'),
        actions: &lt;Widget&gt;[
          IconButton(
            icon: const Icon(Icons.shopping_cart),
            tooltip: 'Open shopping cart',
            onPressed: () {
              // handle the press
            },
          ),
        ],
      ),
      // ...rest of body...
    ],
  ),
)
</code></pre>
<p>{@end-tool}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="flexibleSpace">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.flexibleSpace}
This widget is stacked behind the toolbar and the tab bar. Its height will
be the same as the app bar's overall height.</p><br/>
<p>A flexible space isn't actually flexible unless the [AppBar]'s container
changes the [AppBar]'s size. A [SliverAppBar] in a [CustomScrollView]
changes the [AppBar]'s height when scrolled.</p><br/>
<p>Typically a [FlexibleSpaceBar]. See [FlexibleSpaceBar] for details.
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottom">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.bottom}
This widget appears across the bottom of the app bar.</p><br/>
<p>Typically a [TabBar]. Only widgets that implement [PreferredSizeWidget] can
be used at the bottom of an app bar.
{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[PreferredSize], which can be used to give an arbitrary widget a preferred size.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="elevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.elevation}
The z-coordinate at which to place this app bar relative to its parent.</p><br/>
<p>This property controls the size of the shadow below the app bar if
[shadowColor] is not null.</p><br/>
<p>If [surfaceTintColor] is not null then it will apply a surface tint overlay
to the background color (see [Material.surfaceTintColor] for more
detail).</p><br/>
<p>The value must be non-negative.</p><br/>
<p>If this property is null, then [AppBarTheme.elevation] of
[ThemeData.appBarTheme] is used. If that is also null, the
default value is 4.
{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[scrolledUnderElevation], which will be used when the app bar has
something scrolled underneath it.</li>
<li>[shadowColor], which is the color of the shadow below the app bar.</li>
<li>[surfaceTintColor], which determines the elevation overlay that will
be applied to the background of the app bar.</li>
<li>[shape], which defines the shape of the app bar's [Material] and its
shadow.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="scrolledUnderElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.scrolledUnderElevation}
The elevation that will be used if this app bar has something
scrolled underneath it.</p><br/>
<p>If non-null then it [AppBarTheme.scrolledUnderElevation] of
[ThemeData.appBarTheme] will be used. If that is also null then [elevation]
will be used.</p><br/>
<p>The value must be non-negative.</p><br/>
<p>{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], which will be used if there is no content scrolled under
the app bar.</li>
<li>[shadowColor], which is the color of the shadow below the app bar.</li>
<li>[surfaceTintColor], which determines the elevation overlay that will
be applied to the background of the app bar.</li>
<li>[shape], which defines the shape of the app bar's [Material] and its
shadow.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="notificationPredicate">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A check that specifies which child's [ScrollNotification]s should be
listened to.</p><br/>
<p>By default, checks whether <code>notification.depth == 0</code>. Set it to something
else for more complicated layouts.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shadowColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.shadowColor}
The color of the shadow below the app bar.</p><br/>
<p>If this property is null, then [AppBarTheme.shadowColor] of
[ThemeData.appBarTheme] is used. If that is also null, the default value
is fully opaque black.
{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], which defines the size of the shadow below the app bar.</li>
<li>[shape], which defines the shape of the app bar and its shadow.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="surfaceTintColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.surfaceTintColor}
The color of the surface tint overlay applied to the app bar's
background color to indicate elevation.</p><br/>
<p>If null no overlay will be applied.
{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[Material.surfaceTintColor], which described this feature in more detail.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shape">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.shape}
The shape of the app bar's [Material] as well as its shadow.</p><br/>
<p>If this property is null, then [AppBarTheme.shape] of
[ThemeData.appBarTheme] is used. Both properties default to null.
If both properties are null then the shape of the app bar's [Material]
is just a simple rectangle.</p><br/>
<p>A shadow is only displayed if the [elevation] is greater than
zero.
{@endtemplate}</p><br/>
<p>{@tool dartpad}
This sample demonstrates how to implement a custom app bar shape for the
[shape] property.</p><br/>
<p>** See code in examples/api/lib/material/app_bar/app_bar.4.dart **
{@end-tool}
See also:</p><br/>
<ul>
<li>[elevation], which defines the size of the shadow below the app bar.</li>
<li>[shadowColor], which is the color of the shadow below the app bar.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="backgroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.backgroundColor}
The fill color to use for an app bar's [Material].</p><br/>
<p>If null, then the [AppBarTheme.backgroundColor] is used. If that value is also
null:
In Material v2 (i.e., when [ThemeData.useMaterial3] is false),
then [AppBar] uses the overall theme's [ColorScheme.primary] if the
overall theme's brightness is [Brightness.light], and [ColorScheme.surface]
if the overall theme's brightness is [Brightness.dark].
In Material v3 (i.e., when [ThemeData.useMaterial3] is true),
then [AppBar] uses the overall theme's [ColorScheme.surface]</p><br/>
<p>If this color is a [WidgetStateColor] it will be resolved against
[WidgetState.scrolledUnder] when the content of the app's
primary scrollable overlaps the app bar.
{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[foregroundColor], which specifies the color for icons and text within
the app bar.</li>
<li>[Theme.of], which returns the current overall Material theme as
a [ThemeData].</li>
<li>[ThemeData.colorScheme], the thirteen colors that most Material widget
default colors are based on.</li>
<li>[ColorScheme.brightness], which indicates if the overall [Theme]
is light or dark.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="foregroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.foregroundColor}
The default color for [Text] and [Icon]s within the app bar.</p><br/>
<p>If null, then [AppBarTheme.foregroundColor] is used. If that
value is also null:
In Material v2 (i.e., when [ThemeData.useMaterial3] is false),
then [AppBar] uses the overall theme's [ColorScheme.onPrimary] if the
overall theme's brightness is [Brightness.light], and [ColorScheme.onSurface]
if the overall theme's brightness is [Brightness.dark].
In Material v3 (i.e., when [ThemeData.useMaterial3] is true),
then [AppBar] uses the overall theme's [ColorScheme.onSurface].</p><br/>
<p>This color is used to configure [DefaultTextStyle] that contains
the toolbar's children, and the default [IconTheme] widgets that
are created if [iconTheme] and [actionsIconTheme] are null.
{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[backgroundColor], which specifies the app bar's background color.</li>
<li>[Theme.of], which returns the current overall Material theme as
a [ThemeData].</li>
<li>[ThemeData.colorScheme], the thirteen colors that most Material widget
default colors are based on.</li>
<li>[ColorScheme.brightness], which indicates if the overall [Theme]
is light or dark.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="iconTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.iconTheme}
The color, opacity, and size to use for toolbar icons.</p><br/>
<p>If this property is null, then a copy of [ThemeData.iconTheme]
is used, with the [IconThemeData.color] set to the
app bar's [foregroundColor].
{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[actionsIconTheme], which defines the appearance of icons in
the [actions] list.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="actionsIconTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.actionsIconTheme}
The color, opacity, and size to use for the icons that appear in the app
bar's [actions].</p><br/>
<p>This property should only be used when the [actions] should be
themed differently than the icon that appears in the app bar's [leading]
widget.</p><br/>
<p>If this property is null, then [AppBarTheme.actionsIconTheme] of
[ThemeData.appBarTheme] is used. If that is also null, then the value of
[iconTheme] is used.
{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[iconTheme], which defines the appearance of all of the toolbar icons.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primary" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.primary}
Whether this app bar is being displayed at the top of the screen.</p><br/>
<p>If true, the app bar's toolbar elements and [bottom] widget will be
padded on top by the height of the system status bar. The layout
of the [flexibleSpace] is not affected by the [primary] property.
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="centerTitle" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.centerTitle}
Whether the title should be centered.</p><br/>
<p>If this property is null, then [AppBarTheme.centerTitle] of
[ThemeData.appBarTheme] is used. If that is also null, then value is
adapted to the current [TargetPlatform].
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="excludeHeaderSemantics" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.excludeHeaderSemantics}
Whether the title should be wrapped with header [Semantics].</p><br/>
<p>Defaults to false.
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="titleSpacing">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.titleSpacing}
The spacing around [title] content on the horizontal axis. This spacing is
applied even if there is no [leading] content or [actions]. If you want
[title] to take all the space available, set this value to 0.0.</p><br/>
<p>If this property is null, then [AppBarTheme.titleSpacing] of
[ThemeData.appBarTheme] is used. If that is also null, then the
default value is [NavigationToolbar.kMiddleSpacing].
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="toolbarOpacity">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.toolbarOpacity}
How opaque the toolbar part of the app bar is.</p><br/>
<p>A value of 1.0 is fully opaque, and a value of 0.0 is fully transparent.</p><br/>
<p>Typically, this value is not changed from its default value (1.0). It is
used by [SliverAppBar] to animate the opacity of the toolbar when the app
bar is scrolled.
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottomOpacity">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.bottomOpacity}
How opaque the bottom part of the app bar is.</p><br/>
<p>A value of 1.0 is fully opaque, and a value of 0.0 is fully transparent.</p><br/>
<p>Typically, this value is not changed from its default value (1.0). It is
used by [SliverAppBar] to animate the opacity of the toolbar when the app
bar is scrolled.
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="toolbarHeight">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.toolbarHeight}
Defines the height of the toolbar component of an [AppBar].</p><br/>
<p>By default, the value of [toolbarHeight] is [kToolbarHeight].
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="leadingWidth">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.leadingWidth}
Defines the width of [AppBar.leading] widget.</p><br/>
<p>By default, the value of [AppBar.leadingWidth] is 56.0.
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="toolbarTextStyle">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.toolbarTextStyle}
The default text style for the AppBar's [leading], and
[actions] widgets, but not its [title].</p><br/>
<p>If this property is null, then [AppBarTheme.toolbarTextStyle] of
[ThemeData.appBarTheme] is used. If that is also null, the default
value is a copy of the overall theme's [TextTheme.bodyMedium]
[TextStyle], with color set to the app bar's [foregroundColor].
{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[titleTextStyle], which overrides the default text style for the [title].</li>
<li>[DefaultTextStyle], which overrides the default text style for all of the
widgets in a subtree.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="titleTextStyle">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.titleTextStyle}
The default text style for the AppBar's [title] widget.</p><br/>
<p>If this property is null, then [AppBarTheme.titleTextStyle] of
[ThemeData.appBarTheme] is used. If that is also null, the default
value is a copy of the overall theme's [TextTheme.titleLarge]
[TextStyle], with color set to the app bar's [foregroundColor].
{@endtemplate}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[toolbarTextStyle], which is the default text style for the AppBar's
[title], [leading], and [actions] widgets, also known as the
AppBar's &quot;toolbar&quot;.</li>
<li>[DefaultTextStyle], which overrides the default text style for all of the
widgets in a subtree.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="systemOverlayStyle">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.systemOverlayStyle}
Specifies the style to use for the system overlays (e.g. the status bar on
Android or iOS, the system navigation bar on Android).</p><br/>
<p>If this property is null, then [AppBarTheme.systemOverlayStyle] of
[ThemeData.appBarTheme] is used. If that is also null, an appropriate
[SystemUiOverlayStyle] is calculated based on the [backgroundColor].</p><br/>
<p>The AppBar's descendants are built within a
<code>AnnotatedRegion&lt;SystemUiOverlayStyle&gt;</code> widget, which causes
[SystemChrome.setSystemUIOverlayStyle] to be called
automatically. Apps should not enclose an AppBar with their
own [AnnotatedRegion].
{@endtemplate}
See also:</p><br/>
<ul>
<li>[AnnotatedRegion], for placing [SystemUiOverlayStyle] in the layer tree.</li>
<li>[SystemChrome.setSystemUIOverlayStyle], the imperative API for setting
system overlays style.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="forceMaterialTransparency" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.forceMaterialTransparency}
Forces the AppBar's Material widget type to be [MaterialType.transparency]
(instead of Material's default type).</p><br/>
<p>This will remove the visual display of [backgroundColor] and [elevation],
and affect other characteristics of the AppBar's Material widget.</p><br/>
<p>Provided for cases where the app bar is to be transparent, and gestures
must pass through the app bar to widgets beneath the app bar (i.e. with
[Scaffold.extendBodyBehindAppBar] set to true).</p><br/>
<p>Defaults to false.
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="useDefaultSemanticsOrder" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.useDefaultSemanticsOrder}
Whether to use the default semantic ordering for the app bar's children for
accessibility traversal order.</p><br/>
<p>If this is set to true, the app bar will use the default semantic ordering,
which places the flexible space after the main content in the semantics tree.
This affects how screen readers and other assistive technologies navigate the app bar's content.</p><br/>
<p>Set this to false if you want to customize semantics traversal order in the app bar.
You can then assign [SemanticsSortKey]s to app bar's children to control the order.</p><br/>
<p>Defaults to true.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[SemanticsSortKey], which are keys used to define the accessibility traversal order.
{@endtemplate}</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="clipBehavior" type="ClipAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.Material.clipBehavior}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="actionsPadding">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.appbar.actionsPadding}
The padding between the [actions] and the end of the AppBar.</p><br/>
<p>Defaults to zero.
{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="animateColor" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether the color should be animated.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="Center">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a widget that centers its child.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="widthFactor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>If non-null, sets its width to the child's width multiplied by this factor.</p><br/>
<p>Can be both greater and less than 1.0 but must be non-negative.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="heightFactor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>If non-null, sets its height to the child's height multiplied by this factor.</p><br/>
<p>Can be both greater and less than 1.0 but must be non-negative.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ColorScheme">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Create a ColorScheme instance from the given colors.</p><br/>
<p>[ColorScheme.fromSeed] can be used as a simpler way to create a full
color scheme derived from a single seed color.</p><br/>
<p>For the color parameters that are nullable, it is still recommended
that applications provide values for them. They are only nullable due
to backwards compatibility concerns.</p><br/>
<p>If a color is not provided, the closest fallback color from the given
colors will be used for it (e.g. [primaryContainer] will default
to [primary]). Material Design 3 makes use of these colors for many
component defaults, so for the best results the application should
supply colors for all the parameters. An easy way to ensure this is to
use [ColorScheme.fromSeed] to generate a full set of colors.</p><br/>
<p>During the migration to Material Design 3, if an app's
[ThemeData.useMaterial3] is false, then components will only
use the following colors for defaults:</p><br/>
<ul>
<li>[primary]</li>
<li>[onPrimary]</li>
<li>[secondary]</li>
<li>[onSecondary]</li>
<li>[error]</li>
<li>[onError]</li>
<li>[surface]</li>
<li>[onSurface]
DEPRECATED:</li>
<li>[background]</li>
<li>[onBackground]</li>
</ul>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="brightness" type="BrightnessAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The overall brightness of this color scheme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color displayed most frequently across your apps screens and components.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onPrimary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [primary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[primary] and [onPrimary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryContainer"/>
                    <xs:attribute name="onPrimaryContainer"/>
                    <xs:attribute name="primaryFixed"/>
                    <xs:attribute name="primaryFixedDim"/>
                    <xs:attribute name="onPrimaryFixed"/>
                    <xs:attribute name="onPrimaryFixedVariant"/>
                    <xs:attribute name="secondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An accent color used for less prominent components in the UI, such as
filter chips, while expanding the opportunity for color expression.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSecondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [secondary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[secondary] and [onSecondary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="secondaryContainer"/>
                    <xs:attribute name="onSecondaryContainer"/>
                    <xs:attribute name="secondaryFixed"/>
                    <xs:attribute name="secondaryFixedDim"/>
                    <xs:attribute name="onSecondaryFixed"/>
                    <xs:attribute name="onSecondaryFixedVariant"/>
                    <xs:attribute name="tertiary"/>
                    <xs:attribute name="onTertiary"/>
                    <xs:attribute name="tertiaryContainer"/>
                    <xs:attribute name="onTertiaryContainer"/>
                    <xs:attribute name="tertiaryFixed"/>
                    <xs:attribute name="tertiaryFixedDim"/>
                    <xs:attribute name="onTertiaryFixed"/>
                    <xs:attribute name="onTertiaryFixedVariant"/>
                    <xs:attribute name="error">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for input validation errors, e.g. for
[InputDecoration.errorText].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onError">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [error].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[error] and [onError] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="errorContainer"/>
                    <xs:attribute name="onErrorContainer"/>
                    <xs:attribute name="surface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The background color for widgets like [Scaffold].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSurface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [surface].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[surface] and [onSurface] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="surfaceDim"/>
                    <xs:attribute name="surfaceBright"/>
                    <xs:attribute name="surfaceContainerLowest"/>
                    <xs:attribute name="surfaceContainerLow"/>
                    <xs:attribute name="surfaceContainer"/>
                    <xs:attribute name="surfaceContainerHigh"/>
                    <xs:attribute name="surfaceContainerHighest"/>
                    <xs:attribute name="onSurfaceVariant"/>
                    <xs:attribute name="outline"/>
                    <xs:attribute name="outlineVariant"/>
                    <xs:attribute name="shadow"/>
                    <xs:attribute name="scrim"/>
                    <xs:attribute name="inverseSurface"/>
                    <xs:attribute name="onInverseSurface"/>
                    <xs:attribute name="inversePrimary"/>
                    <xs:attribute name="surfaceTint"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ColorScheme.fromSeed">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Generate a [ColorScheme] derived from the given <code>seedColor</code>.</p><br/>
<p>Using the <code>seedColor</code> as a starting point, a set of tonal palettes are
constructed. By default, the tonal palettes are based on the Material 3
Color system and provide all of the [ColorScheme] colors. These colors are
designed to work well together and meet contrast requirements for
accessibility.</p><br/>
<p>If any of the optional color parameters are non-null they will be
used in place of the generated colors for that field in the resulting
color scheme. This allows apps to override specific colors for their
needs.</p><br/>
<p>Given the nature of the algorithm, the <code>seedColor</code> may not wind up as
one of the ColorScheme colors.</p><br/>
<p>The <code>dynamicSchemeVariant</code> parameter creates different types of
[DynamicScheme]s, which are used to generate different styles of [ColorScheme]s.
By default, <code>dynamicSchemeVariant</code> is set to <code>tonalSpot</code>. A [ColorScheme]
constructed by <code>dynamicSchemeVariant.tonalSpot</code> has pastel palettes and
won't be too &quot;colorful&quot; even if the <code>seedColor</code> has a high chroma value.
If the resulting color scheme is too dark, consider setting <code>dynamicSchemeVariant</code>
to [DynamicSchemeVariant.fidelity], whose palettes match the seed color.</p><br/>
<p>The <code>contrastLevel</code> parameter indicates the contrast level between color
pairs, such as [primary] and [onPrimary]. 0.0 is the default (normal);
-1.0 is the lowest; 1.0 is the highest. From Material Design guideline, the
medium and high contrast correspond to 0.5 and 1.0 respectively.</p><br/>
<p>{@tool dartpad}
This sample shows how to use [ColorScheme.fromSeed] to create dynamic
color schemes with different [DynamicSchemeVariant]s and different
contrast level.</p><br/>
<p>** See code in examples/api/lib/material/color_scheme/color_scheme.0.dart **
{@end-tool}</p><br/>
<p>See also:</p><br/>
<ul>
<li><a href="https://m3.material.io/styles/color/the-color-system/color-roles">https://m3.material.io/styles/color/the-color-system/color-roles</a>, the
Material 3 Color system specification.</li>
<li><a href="https://pub.dev/packages/material_color_utilities">https://pub.dev/packages/material_color_utilities</a>, the package
used to generate the tonal palettes needed for the scheme.</li>
</ul>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="seedColor"/>
                    <xs:attribute name="brightness" type="BrightnessAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The overall brightness of this color scheme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dynamicSchemeVariant" type="DynamicSchemeVariantAttributeType"/>
                    <xs:attribute name="contrastLevel"/>
                    <xs:attribute name="primary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color displayed most frequently across your apps screens and components.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onPrimary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [primary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[primary] and [onPrimary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryContainer"/>
                    <xs:attribute name="onPrimaryContainer"/>
                    <xs:attribute name="primaryFixed"/>
                    <xs:attribute name="primaryFixedDim"/>
                    <xs:attribute name="onPrimaryFixed"/>
                    <xs:attribute name="onPrimaryFixedVariant"/>
                    <xs:attribute name="secondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An accent color used for less prominent components in the UI, such as
filter chips, while expanding the opportunity for color expression.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSecondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [secondary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[secondary] and [onSecondary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="secondaryContainer"/>
                    <xs:attribute name="onSecondaryContainer"/>
                    <xs:attribute name="secondaryFixed"/>
                    <xs:attribute name="secondaryFixedDim"/>
                    <xs:attribute name="onSecondaryFixed"/>
                    <xs:attribute name="onSecondaryFixedVariant"/>
                    <xs:attribute name="tertiary"/>
                    <xs:attribute name="onTertiary"/>
                    <xs:attribute name="tertiaryContainer"/>
                    <xs:attribute name="onTertiaryContainer"/>
                    <xs:attribute name="tertiaryFixed"/>
                    <xs:attribute name="tertiaryFixedDim"/>
                    <xs:attribute name="onTertiaryFixed"/>
                    <xs:attribute name="onTertiaryFixedVariant"/>
                    <xs:attribute name="error">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for input validation errors, e.g. for
[InputDecoration.errorText].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onError">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [error].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[error] and [onError] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="errorContainer"/>
                    <xs:attribute name="onErrorContainer"/>
                    <xs:attribute name="outline"/>
                    <xs:attribute name="outlineVariant"/>
                    <xs:attribute name="surface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The background color for widgets like [Scaffold].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSurface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [surface].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[surface] and [onSurface] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="surfaceDim"/>
                    <xs:attribute name="surfaceBright"/>
                    <xs:attribute name="surfaceContainerLowest"/>
                    <xs:attribute name="surfaceContainerLow"/>
                    <xs:attribute name="surfaceContainer"/>
                    <xs:attribute name="surfaceContainerHigh"/>
                    <xs:attribute name="surfaceContainerHighest"/>
                    <xs:attribute name="onSurfaceVariant"/>
                    <xs:attribute name="inverseSurface"/>
                    <xs:attribute name="onInverseSurface"/>
                    <xs:attribute name="inversePrimary"/>
                    <xs:attribute name="shadow"/>
                    <xs:attribute name="scrim"/>
                    <xs:attribute name="surfaceTint"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ColorScheme.light">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Create a light ColorScheme based on a purple primary color that matches the
<a href="https://material.io/design/color/the-color-system.html#color-theme-creation">baseline Material 2 color scheme</a>.</p><br/>
<p>This constructor shouldn't be used to update the Material 3 color scheme.</p><br/>
<p>For Material 3, use [ColorScheme.fromSeed] to create a color scheme
from a single seed color based on the Material 3 color system.</p><br/>
<p>{@tool snippet}
This example demonstrates how to create a color scheme similar to [ColorScheme.light]
using the [ColorScheme.fromSeed] constructor:</p><br/>
<pre><code class="language-dart">colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff6200ee)).copyWith(
  primaryContainer: const Color(0xff6200ee),
  onPrimaryContainer: Colors.white,
  secondaryContainer: const Color(0xff03dac6),
  onSecondaryContainer: Colors.black,
  error: const Color(0xffb00020),
  onError: Colors.white,
),
</code></pre>
<p>{@end-tool}</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="brightness" type="BrightnessAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The overall brightness of this color scheme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color displayed most frequently across your apps screens and components.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onPrimary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [primary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[primary] and [onPrimary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryContainer"/>
                    <xs:attribute name="onPrimaryContainer"/>
                    <xs:attribute name="primaryFixed"/>
                    <xs:attribute name="primaryFixedDim"/>
                    <xs:attribute name="onPrimaryFixed"/>
                    <xs:attribute name="onPrimaryFixedVariant"/>
                    <xs:attribute name="secondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An accent color used for less prominent components in the UI, such as
filter chips, while expanding the opportunity for color expression.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSecondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [secondary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[secondary] and [onSecondary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="secondaryContainer"/>
                    <xs:attribute name="onSecondaryContainer"/>
                    <xs:attribute name="secondaryFixed"/>
                    <xs:attribute name="secondaryFixedDim"/>
                    <xs:attribute name="onSecondaryFixed"/>
                    <xs:attribute name="onSecondaryFixedVariant"/>
                    <xs:attribute name="tertiary"/>
                    <xs:attribute name="onTertiary"/>
                    <xs:attribute name="tertiaryContainer"/>
                    <xs:attribute name="onTertiaryContainer"/>
                    <xs:attribute name="tertiaryFixed"/>
                    <xs:attribute name="tertiaryFixedDim"/>
                    <xs:attribute name="onTertiaryFixed"/>
                    <xs:attribute name="onTertiaryFixedVariant"/>
                    <xs:attribute name="error">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for input validation errors, e.g. for
[InputDecoration.errorText].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onError">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [error].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[error] and [onError] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="errorContainer"/>
                    <xs:attribute name="onErrorContainer"/>
                    <xs:attribute name="surface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The background color for widgets like [Scaffold].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSurface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [surface].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[surface] and [onSurface] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="surfaceDim"/>
                    <xs:attribute name="surfaceBright"/>
                    <xs:attribute name="surfaceContainerLowest"/>
                    <xs:attribute name="surfaceContainerLow"/>
                    <xs:attribute name="surfaceContainer"/>
                    <xs:attribute name="surfaceContainerHigh"/>
                    <xs:attribute name="surfaceContainerHighest"/>
                    <xs:attribute name="onSurfaceVariant"/>
                    <xs:attribute name="outline"/>
                    <xs:attribute name="outlineVariant"/>
                    <xs:attribute name="shadow"/>
                    <xs:attribute name="scrim"/>
                    <xs:attribute name="inverseSurface"/>
                    <xs:attribute name="onInverseSurface"/>
                    <xs:attribute name="inversePrimary"/>
                    <xs:attribute name="surfaceTint"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ColorScheme.dark">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Create the dark color scheme that matches the
<a href="https://material.io/design/color/dark-theme.html#ui-application">baseline Material 2 color scheme</a>.</p><br/>
<p>This constructor shouldn't be used to update the Material 3 color scheme.</p><br/>
<p>For Material 3, use [ColorScheme.fromSeed] to create a color scheme
from a single seed color based on the Material 3 color system.
Override the <code>brightness</code> property of [ColorScheme.fromSeed] to create a
dark color scheme.</p><br/>
<p>{@tool snippet}
This example demonstrates how to create a color scheme similar to [ColorScheme.dark]
using the [ColorScheme.fromSeed] constructor:</p><br/>
<pre><code class="language-dart">colorScheme: ColorScheme.fromSeed(
  seedColor: const Color(0xffbb86fc),
  brightness: Brightness.dark,
).copyWith(
  primaryContainer: const Color(0xffbb86fc),
  onPrimaryContainer: Colors.black,
  secondaryContainer: const Color(0xff03dac6),
  onSecondaryContainer: Colors.black,
  error: const Color(0xffcf6679),
  onError: Colors.black,
),
</code></pre>
<p>{@end-tool}</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="brightness" type="BrightnessAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The overall brightness of this color scheme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color displayed most frequently across your apps screens and components.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onPrimary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [primary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[primary] and [onPrimary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryContainer"/>
                    <xs:attribute name="onPrimaryContainer"/>
                    <xs:attribute name="primaryFixed"/>
                    <xs:attribute name="primaryFixedDim"/>
                    <xs:attribute name="onPrimaryFixed"/>
                    <xs:attribute name="onPrimaryFixedVariant"/>
                    <xs:attribute name="secondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An accent color used for less prominent components in the UI, such as
filter chips, while expanding the opportunity for color expression.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSecondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [secondary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[secondary] and [onSecondary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="secondaryContainer"/>
                    <xs:attribute name="onSecondaryContainer"/>
                    <xs:attribute name="secondaryFixed"/>
                    <xs:attribute name="secondaryFixedDim"/>
                    <xs:attribute name="onSecondaryFixed"/>
                    <xs:attribute name="onSecondaryFixedVariant"/>
                    <xs:attribute name="tertiary"/>
                    <xs:attribute name="onTertiary"/>
                    <xs:attribute name="tertiaryContainer"/>
                    <xs:attribute name="onTertiaryContainer"/>
                    <xs:attribute name="tertiaryFixed"/>
                    <xs:attribute name="tertiaryFixedDim"/>
                    <xs:attribute name="onTertiaryFixed"/>
                    <xs:attribute name="onTertiaryFixedVariant"/>
                    <xs:attribute name="error">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for input validation errors, e.g. for
[InputDecoration.errorText].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onError">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [error].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[error] and [onError] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="errorContainer"/>
                    <xs:attribute name="onErrorContainer"/>
                    <xs:attribute name="surface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The background color for widgets like [Scaffold].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSurface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [surface].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[surface] and [onSurface] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="surfaceDim"/>
                    <xs:attribute name="surfaceBright"/>
                    <xs:attribute name="surfaceContainerLowest"/>
                    <xs:attribute name="surfaceContainerLow"/>
                    <xs:attribute name="surfaceContainer"/>
                    <xs:attribute name="surfaceContainerHigh"/>
                    <xs:attribute name="surfaceContainerHighest"/>
                    <xs:attribute name="onSurfaceVariant"/>
                    <xs:attribute name="outline"/>
                    <xs:attribute name="outlineVariant"/>
                    <xs:attribute name="shadow"/>
                    <xs:attribute name="scrim"/>
                    <xs:attribute name="inverseSurface"/>
                    <xs:attribute name="onInverseSurface"/>
                    <xs:attribute name="inversePrimary"/>
                    <xs:attribute name="surfaceTint"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ColorScheme.highContrastLight">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Create a high contrast ColorScheme based on a purple primary color that
matches the <a href="https://material.io/design/color/the-color-system.html#color-theme-creation">baseline Material 2 color scheme</a>.</p><br/>
<p>This constructor shouldn't be used to update the Material 3 color scheme.</p><br/>
<p>For Material 3, use [ColorScheme.fromSeed] to create a color scheme
from a single seed color based on the Material 3 color system. To create a
high-contrast color scheme, set <code>contrastLevel</code> to 1.0.</p><br/>
<p>{@tool snippet}
This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastLight]
using the [ColorScheme.fromSeed] constructor:</p><br/>
<pre><code class="language-dart">colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xff0000ba)).copyWith(
  primaryContainer: const Color(0xff0000ba),
  onPrimaryContainer: Colors.white,
  secondaryContainer: const Color(0xff66fff9),
  onSecondaryContainer: Colors.black,
  error: const Color(0xff790000),
  onError: Colors.white,
),
</code></pre>
<p>{@end-tool}</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="brightness" type="BrightnessAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The overall brightness of this color scheme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color displayed most frequently across your apps screens and components.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onPrimary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [primary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[primary] and [onPrimary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryContainer"/>
                    <xs:attribute name="onPrimaryContainer"/>
                    <xs:attribute name="primaryFixed"/>
                    <xs:attribute name="primaryFixedDim"/>
                    <xs:attribute name="onPrimaryFixed"/>
                    <xs:attribute name="onPrimaryFixedVariant"/>
                    <xs:attribute name="secondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An accent color used for less prominent components in the UI, such as
filter chips, while expanding the opportunity for color expression.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSecondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [secondary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[secondary] and [onSecondary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="secondaryContainer"/>
                    <xs:attribute name="onSecondaryContainer"/>
                    <xs:attribute name="secondaryFixed"/>
                    <xs:attribute name="secondaryFixedDim"/>
                    <xs:attribute name="onSecondaryFixed"/>
                    <xs:attribute name="onSecondaryFixedVariant"/>
                    <xs:attribute name="tertiary"/>
                    <xs:attribute name="onTertiary"/>
                    <xs:attribute name="tertiaryContainer"/>
                    <xs:attribute name="onTertiaryContainer"/>
                    <xs:attribute name="tertiaryFixed"/>
                    <xs:attribute name="tertiaryFixedDim"/>
                    <xs:attribute name="onTertiaryFixed"/>
                    <xs:attribute name="onTertiaryFixedVariant"/>
                    <xs:attribute name="error">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for input validation errors, e.g. for
[InputDecoration.errorText].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onError">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [error].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[error] and [onError] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="errorContainer"/>
                    <xs:attribute name="onErrorContainer"/>
                    <xs:attribute name="surface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The background color for widgets like [Scaffold].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSurface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [surface].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[surface] and [onSurface] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="surfaceDim"/>
                    <xs:attribute name="surfaceBright"/>
                    <xs:attribute name="surfaceContainerLowest"/>
                    <xs:attribute name="surfaceContainerLow"/>
                    <xs:attribute name="surfaceContainer"/>
                    <xs:attribute name="surfaceContainerHigh"/>
                    <xs:attribute name="surfaceContainerHighest"/>
                    <xs:attribute name="onSurfaceVariant"/>
                    <xs:attribute name="outline"/>
                    <xs:attribute name="outlineVariant"/>
                    <xs:attribute name="shadow"/>
                    <xs:attribute name="scrim"/>
                    <xs:attribute name="inverseSurface"/>
                    <xs:attribute name="onInverseSurface"/>
                    <xs:attribute name="inversePrimary"/>
                    <xs:attribute name="surfaceTint"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ColorScheme.highContrastDark">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Create a high contrast ColorScheme based on the dark
<a href="https://material.io/design/color/dark-theme.html#ui-application">baseline Material 2 color scheme</a>.</p><br/>
<p>This constructor shouldn't be used to update the Material 3 color scheme.</p><br/>
<p>For Material 3, use [ColorScheme.fromSeed] to create a color scheme
from a single seed color based on the Material 3 color system.
Override the <code>brightness</code> property of [ColorScheme.fromSeed] to create a
dark color scheme. To create a high-contrast color scheme, set
<code>contrastLevel</code> to 1.0.</p><br/>
<p>{@tool snippet}
This example demonstrates how to create a color scheme similar to [ColorScheme.highContrastDark]
using the [ColorScheme.fromSeed] constructor:</p><br/>
<pre><code class="language-dart">colorScheme: ColorScheme.fromSeed(
  seedColor: const Color(0xffefb7ff),
  brightness: Brightness.dark,
).copyWith(
  primaryContainer: const Color(0xffefb7ff),
  onPrimaryContainer: Colors.black,
  secondaryContainer: const Color(0xff66fff9),
  onSecondaryContainer: Colors.black,
  error: const Color(0xff9b374d),
  onError: Colors.white,
),
</code></pre>
<p>{@end-tool}</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="brightness" type="BrightnessAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The overall brightness of this color scheme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color displayed most frequently across your apps screens and components.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onPrimary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [primary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[primary] and [onPrimary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryContainer"/>
                    <xs:attribute name="onPrimaryContainer"/>
                    <xs:attribute name="primaryFixed"/>
                    <xs:attribute name="primaryFixedDim"/>
                    <xs:attribute name="onPrimaryFixed"/>
                    <xs:attribute name="onPrimaryFixedVariant"/>
                    <xs:attribute name="secondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An accent color used for less prominent components in the UI, such as
filter chips, while expanding the opportunity for color expression.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSecondary">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [secondary].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[secondary] and [onSecondary] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="secondaryContainer"/>
                    <xs:attribute name="onSecondaryContainer"/>
                    <xs:attribute name="secondaryFixed"/>
                    <xs:attribute name="secondaryFixedDim"/>
                    <xs:attribute name="onSecondaryFixed"/>
                    <xs:attribute name="onSecondaryFixedVariant"/>
                    <xs:attribute name="tertiary"/>
                    <xs:attribute name="onTertiary"/>
                    <xs:attribute name="tertiaryContainer"/>
                    <xs:attribute name="onTertiaryContainer"/>
                    <xs:attribute name="tertiaryFixed"/>
                    <xs:attribute name="tertiaryFixedDim"/>
                    <xs:attribute name="onTertiaryFixed"/>
                    <xs:attribute name="onTertiaryFixedVariant"/>
                    <xs:attribute name="error">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for input validation errors, e.g. for
[InputDecoration.errorText].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onError">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [error].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[error] and [onError] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="errorContainer"/>
                    <xs:attribute name="onErrorContainer"/>
                    <xs:attribute name="surface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The background color for widgets like [Scaffold].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onSurface">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A color that's clearly legible when drawn on [surface].</p><br/>
<p>To ensure that an app is accessible, a contrast ratio between
[surface] and [onSurface] of at least 4.5:1 is recommended. See
<a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html</a>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="surfaceDim"/>
                    <xs:attribute name="surfaceBright"/>
                    <xs:attribute name="surfaceContainerLowest"/>
                    <xs:attribute name="surfaceContainerLow"/>
                    <xs:attribute name="surfaceContainer"/>
                    <xs:attribute name="surfaceContainerHigh"/>
                    <xs:attribute name="surfaceContainerHighest"/>
                    <xs:attribute name="onSurfaceVariant"/>
                    <xs:attribute name="outline"/>
                    <xs:attribute name="outlineVariant"/>
                    <xs:attribute name="shadow"/>
                    <xs:attribute name="scrim"/>
                    <xs:attribute name="inverseSurface"/>
                    <xs:attribute name="onInverseSurface"/>
                    <xs:attribute name="inversePrimary"/>
                    <xs:attribute name="surfaceTint"/>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ColorScheme.fromSwatch">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a color scheme from a [MaterialColor] swatch.</p><br/>
<p>In Material 3, this constructor is ignored by [ThemeData] when creating
its default color scheme. Instead, [ThemeData] uses [ColorScheme.fromSeed]
to create its default color scheme. This constructor shouldn't be used
to update the Material 3 color scheme. It will be phased out gradually;
see https://github.com/flutter/flutter/issues/120064 for more details.</p><br/>
<p>If [ThemeData.useMaterial3] is false, then this constructor is used by
[ThemeData] to create its default color scheme.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="primarySwatch"/>
                    <xs:attribute name="accentColor"/>
                    <xs:attribute name="cardColor"/>
                    <xs:attribute name="backgroundColor"/>
                    <xs:attribute name="errorColor"/>
                    <xs:attribute name="brightness" type="BrightnessAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The overall brightness of this color scheme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="Column">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a vertical array of children.</p><br/>
<p>If [crossAxisAlignment] is [CrossAxisAlignment.baseline], then
[textBaseline] must not be null.</p><br/>
<p>The [textDirection] argument defaults to the ambient [Directionality], if
any. If there is no ambient directionality, and a text direction is going
to be necessary to disambiguate <code>start</code> or <code>end</code> values for the
[crossAxisAlignment], the [textDirection] must not be null.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="mainAxisAlignment" type="MainAxisAlignmentAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>How the children should be placed along the main axis.</p><br/>
<p>For example, [MainAxisAlignment.start], the default, places the children
at the start (i.e., the left for a [Row] or the top for a [Column]) of the
main axis.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="mainAxisSize" type="MainAxisSizeAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>How much space should be occupied in the main axis.</p><br/>
<p>After allocating space to children, there might be some remaining free
space. This value controls whether to maximize or minimize the amount of
free space, subject to the incoming layout constraints.</p><br/>
<p>If some children have a non-zero flex factors (and none have a fit of
[FlexFit.loose]), they will expand to consume all the available space and
there will be no remaining free space to maximize or minimize, making this
value irrelevant to the final layout.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="crossAxisAlignment" type="CrossAxisAlignmentAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>How the children should be placed along the cross axis.</p><br/>
<p>For example, [CrossAxisAlignment.center], the default, centers the
children in the cross axis (e.g., horizontally for a [Column]).</p><br/>
<p>When the cross axis is vertical (as for a [Row]) and the children
contain text, consider using [CrossAxisAlignment.baseline] instead.
This typically produces better visual results if the different children
have text with different font metrics, for example because they differ in
[TextStyle.fontSize] or other [TextStyle] properties, or because
they use different fonts due to being written in different scripts.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textDirection" type="TextDirectionAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Determines the order to lay children out horizontally and how to interpret
<code>start</code> and <code>end</code> in the horizontal direction.</p><br/>
<p>Defaults to the ambient [Directionality].</p><br/>
<p>If [textDirection] is [TextDirection.rtl], then the direction in which
text flows starts from right to left. Otherwise, if [textDirection] is
[TextDirection.ltr], then the direction in which text flows starts from
left to right.</p><br/>
<p>If the [direction] is [Axis.horizontal], this controls the order in which
the children are positioned (left-to-right or right-to-left), and the
meaning of the [mainAxisAlignment] property's [MainAxisAlignment.start] and
[MainAxisAlignment.end] values.</p><br/>
<p>If the [direction] is [Axis.horizontal], and either the
[mainAxisAlignment] is either [MainAxisAlignment.start] or
[MainAxisAlignment.end], or there's more than one child, then the
[textDirection] (or the ambient [Directionality]) must not be null.</p><br/>
<p>If the [direction] is [Axis.vertical], this controls the meaning of the
[crossAxisAlignment] property's [CrossAxisAlignment.start] and
[CrossAxisAlignment.end] values.</p><br/>
<p>If the [direction] is [Axis.vertical], and the [crossAxisAlignment] is
either [CrossAxisAlignment.start] or [CrossAxisAlignment.end], then the
[textDirection] (or the ambient [Directionality]) must not be null.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="verticalDirection" type="VerticalDirectionAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Determines the order to lay children out vertically and how to interpret
<code>start</code> and <code>end</code> in the vertical direction.</p><br/>
<p>Defaults to [VerticalDirection.down].</p><br/>
<p>If the [direction] is [Axis.vertical], this controls which order children
are painted in (down or up), the meaning of the [mainAxisAlignment]
property's [MainAxisAlignment.start] and [MainAxisAlignment.end] values.</p><br/>
<p>If the [direction] is [Axis.vertical], and either the [mainAxisAlignment]
is either [MainAxisAlignment.start] or [MainAxisAlignment.end], or there's
more than one child, then the [verticalDirection] must not be null.</p><br/>
<p>If the [direction] is [Axis.horizontal], this controls the meaning of the
[crossAxisAlignment] property's [CrossAxisAlignment.start] and
[CrossAxisAlignment.end] values.</p><br/>
<p>If the [direction] is [Axis.horizontal], and the [crossAxisAlignment] is
either [CrossAxisAlignment.start] or [CrossAxisAlignment.end], then the
[verticalDirection] must not be null.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textBaseline" type="TextBaselineAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>If aligning items according to their baseline, which baseline to use.</p><br/>
<p>This must be set if using baseline alignment. There is no default because there is no
way for the framework to know the correct baseline <em>a priori</em>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="spacing">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.rendering.RenderFlex.spacing}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="children">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The widgets below this widget in the tree.</p><br/>
<p>If this list is going to be mutated, it is usually wise to put a [Key] on
each of the child widgets, so that the framework can match old
configurations to new configurations and maintain the underlying render
objects.</p><br/>
<p>Also, a [Widget] in Flutter is immutable, so directly modifying the
[children] such as <code>someMultiChildRenderObjectWidget.children.add(...)</code> or
as the example code below will result in incorrect behaviors. Whenever the
children list is modified, a new list object should be provided.</p><br/>
<pre><code class="language-dart">// This code is incorrect.
class SomeWidgetState extends State&lt;SomeWidget&gt; {
  final List&lt;Widget&gt; _children = &lt;Widget&gt;[];

  void someHandler() {
    setState(() {
      _children.add(const ChildWidget());
    });
  }

  @override
  Widget build(BuildContext context) {
    // Reusing `List&lt;Widget&gt; _children` here is problematic.
    return Row(children: _children);
  }
}
</code></pre>
<p>The following code corrects the problem mentioned above.</p><br/>
<pre><code class="language-dart">class SomeWidgetState extends State&lt;SomeWidget&gt; {
  final List&lt;Widget&gt; _children = &lt;Widget&gt;[];

  void someHandler() {
    setState(() {
      // The key here allows Flutter to reuse the underlying render
      // objects even if the children list is recreated.
      _children.add(ChildWidget(key: UniqueKey()));
    });
  }

  @override
  Widget build(BuildContext context) {
    // Always create a new list of children as a Widget is immutable.
    return Row(children: _children.toList());
  }
}
</code></pre>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="FloatingActionButton">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a circular floating action button.</p><br/>
<p>The [elevation], [highlightElevation], and [disabledElevation] parameters,
if specified, must be non-negative.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="tooltip">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Text that describes the action that will occur when the button is pressed.</p><br/>
<p>This text is displayed when the user long-presses on the button and is
used for accessibility.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="foregroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The default foreground color for icons and text within the button.</p><br/>
<p>If this property is null, then the [FloatingActionButtonThemeData.foregroundColor]
of [ThemeData.floatingActionButtonTheme] is used. If that property is also
null, then the [ColorScheme.onPrimaryContainer] color of [ThemeData.colorScheme]
is used. If [ThemeData.useMaterial3] is set to false, then the
[ColorScheme.onSecondary] color of [ThemeData.colorScheme] is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="backgroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The button's background color.</p><br/>
<p>If this property is null, then the [FloatingActionButtonThemeData.backgroundColor]
of [ThemeData.floatingActionButtonTheme] is used. If that property is also
null, then the [ColorScheme.primaryContainer] color of [ThemeData.colorScheme]
is used. If [ThemeData.useMaterial3] is set to false, then the
[ColorScheme.secondary] color of [ThemeData.colorScheme] is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for filling the button when the button has input focus.</p><br/>
<p>In Material3, defaults to [ColorScheme.onPrimaryContainer] with opacity 0.1.
In Material 2, it defaults to [ThemeData.focusColor] for the current theme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hoverColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for filling the button when the button has a pointer
hovering over it.</p><br/>
<p>Defaults to [ThemeData.hoverColor] for the current theme in Material 2. In
Material 3, defaults to [ColorScheme.onPrimaryContainer] with opacity 0.08.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="splashColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The splash color for this [FloatingActionButton]'s [InkWell].</p><br/>
<p>If null, [FloatingActionButtonThemeData.splashColor] is used, if that is
null, [ThemeData.splashColor] is used in Material 2; [ColorScheme.onPrimaryContainer]
with opacity 0.1 is used in Material 3.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="heroTag">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The tag to apply to the button's [Hero] widget.</p><br/>
<p>Defaults to a tag that matches other floating action buttons.</p><br/>
<p>Set this to null explicitly if you don't want the floating action button to
have a hero tag.</p><br/>
<p>If this is not explicitly set, then there can only be one
[FloatingActionButton] per route (that is, per screen), since otherwise
there would be a tag conflict (multiple heroes on one route can't have the
same tag). The Material Design specification recommends only using one
floating action button per screen.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="elevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 6, the appropriate elevation for floating action buttons. The
value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the button has the input focus.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 8, the appropriate elevation for floating action buttons
while they have focus. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hoverElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the button is enabled and has a pointer hovering over it.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 8, the appropriate elevation for floating action buttons while
they have a pointer hovering over them. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="highlightElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the user is touching the button.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 12, the appropriate elevation for floating action buttons
while they are being touched. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="disabledElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button when the button is disabled
([onPressed] is null).</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to the same value as [elevation]. Setting this to zero makes the
floating action button work similar to an [ElevatedButton] but the titular
&quot;floating&quot; effect is lost. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onPressed">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The callback that is called when the button is tapped or otherwise activated.</p><br/>
<p>If this is set to null, the button will be disabled.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="mouseCursor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.RawMaterialButton.mouseCursor}</p><br/>
<p>If this property is null, [WidgetStateMouseCursor.clickable] will be used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="mini" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls the size of this button.</p><br/>
<p>By default, floating action buttons are non-mini and have a height and
width of 56.0 logical pixels. Mini floating action buttons have a height
and width of 40.0 logical pixels with a layout width and height of 48.0
logical pixels. (The extra 4 pixels of padding on each side are added as a
result of the floating action button having [MaterialTapTargetSize.padded]
set on the underlying [RawMaterialButton.materialTapTargetSize].)</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shape">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The shape of the button's [Material].</p><br/>
<p>The button's highlight and splash are clipped to this shape. If the
button has an elevation, then its drop shadow is defined by this
shape as well.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="clipBehavior" type="ClipAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.Material.clipBehavior}</p><br/>
<p>Defaults to [Clip.none].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusNode">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.Focus.focusNode}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="autofocus" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.Focus.autofocus}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="materialTapTargetSize" type="MaterialTapTargetSizeAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Configures the minimum size of the tap target.</p><br/>
<p>Defaults to [ThemeData.materialTapTargetSize].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[MaterialTapTargetSize], for a description of how this affects tap targets.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="isExtended" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>True if this is an &quot;extended&quot; floating action button.</p><br/>
<p>Typically &quot;extended&quot; buttons have a [StadiumBorder] [shape]
and have been created with the [FloatingActionButton.extended]
constructor.</p><br/>
<p>The [Scaffold] animates the appearance of ordinary floating
action buttons with scale and rotation transitions. Extended
floating action buttons are scaled and faded in.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="enableFeedback" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether detected gestures should provide acoustic and/or haptic feedback.</p><br/>
<p>For example, on Android a tap will produce a clicking sound and a
long-press will produce a short vibration, when feedback is enabled.</p><br/>
<p>If null, [FloatingActionButtonThemeData.enableFeedback] is used.
If both are null, then default value is true.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[Feedback] for providing platform-specific feedback to certain actions.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="FloatingActionButton.small">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a small circular floating action button.</p><br/>
<p>This constructor overrides the default size constraints of the floating
action button.</p><br/>
<p>The [elevation], [focusElevation], [hoverElevation], [highlightElevation],
and [disabledElevation] parameters, if specified, must be non-negative.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="tooltip">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Text that describes the action that will occur when the button is pressed.</p><br/>
<p>This text is displayed when the user long-presses on the button and is
used for accessibility.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="foregroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The default foreground color for icons and text within the button.</p><br/>
<p>If this property is null, then the [FloatingActionButtonThemeData.foregroundColor]
of [ThemeData.floatingActionButtonTheme] is used. If that property is also
null, then the [ColorScheme.onPrimaryContainer] color of [ThemeData.colorScheme]
is used. If [ThemeData.useMaterial3] is set to false, then the
[ColorScheme.onSecondary] color of [ThemeData.colorScheme] is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="backgroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The button's background color.</p><br/>
<p>If this property is null, then the [FloatingActionButtonThemeData.backgroundColor]
of [ThemeData.floatingActionButtonTheme] is used. If that property is also
null, then the [ColorScheme.primaryContainer] color of [ThemeData.colorScheme]
is used. If [ThemeData.useMaterial3] is set to false, then the
[ColorScheme.secondary] color of [ThemeData.colorScheme] is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for filling the button when the button has input focus.</p><br/>
<p>In Material3, defaults to [ColorScheme.onPrimaryContainer] with opacity 0.1.
In Material 2, it defaults to [ThemeData.focusColor] for the current theme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hoverColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for filling the button when the button has a pointer
hovering over it.</p><br/>
<p>Defaults to [ThemeData.hoverColor] for the current theme in Material 2. In
Material 3, defaults to [ColorScheme.onPrimaryContainer] with opacity 0.08.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="splashColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The splash color for this [FloatingActionButton]'s [InkWell].</p><br/>
<p>If null, [FloatingActionButtonThemeData.splashColor] is used, if that is
null, [ThemeData.splashColor] is used in Material 2; [ColorScheme.onPrimaryContainer]
with opacity 0.1 is used in Material 3.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="heroTag">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The tag to apply to the button's [Hero] widget.</p><br/>
<p>Defaults to a tag that matches other floating action buttons.</p><br/>
<p>Set this to null explicitly if you don't want the floating action button to
have a hero tag.</p><br/>
<p>If this is not explicitly set, then there can only be one
[FloatingActionButton] per route (that is, per screen), since otherwise
there would be a tag conflict (multiple heroes on one route can't have the
same tag). The Material Design specification recommends only using one
floating action button per screen.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="elevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 6, the appropriate elevation for floating action buttons. The
value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the button has the input focus.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 8, the appropriate elevation for floating action buttons
while they have focus. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hoverElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the button is enabled and has a pointer hovering over it.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 8, the appropriate elevation for floating action buttons while
they have a pointer hovering over them. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="highlightElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the user is touching the button.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 12, the appropriate elevation for floating action buttons
while they are being touched. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="disabledElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button when the button is disabled
([onPressed] is null).</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to the same value as [elevation]. Setting this to zero makes the
floating action button work similar to an [ElevatedButton] but the titular
&quot;floating&quot; effect is lost. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onPressed">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The callback that is called when the button is tapped or otherwise activated.</p><br/>
<p>If this is set to null, the button will be disabled.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="mouseCursor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.RawMaterialButton.mouseCursor}</p><br/>
<p>If this property is null, [WidgetStateMouseCursor.clickable] will be used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shape">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The shape of the button's [Material].</p><br/>
<p>The button's highlight and splash are clipped to this shape. If the
button has an elevation, then its drop shadow is defined by this
shape as well.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="clipBehavior" type="ClipAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.Material.clipBehavior}</p><br/>
<p>Defaults to [Clip.none].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusNode">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.Focus.focusNode}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="autofocus" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.Focus.autofocus}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="materialTapTargetSize" type="MaterialTapTargetSizeAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Configures the minimum size of the tap target.</p><br/>
<p>Defaults to [ThemeData.materialTapTargetSize].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[MaterialTapTargetSize], for a description of how this affects tap targets.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="enableFeedback" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether detected gestures should provide acoustic and/or haptic feedback.</p><br/>
<p>For example, on Android a tap will produce a clicking sound and a
long-press will produce a short vibration, when feedback is enabled.</p><br/>
<p>If null, [FloatingActionButtonThemeData.enableFeedback] is used.
If both are null, then default value is true.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[Feedback] for providing platform-specific feedback to certain actions.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="FloatingActionButton.large">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a large circular floating action button.</p><br/>
<p>This constructor overrides the default size constraints of the floating
action button.</p><br/>
<p>The [elevation], [focusElevation], [hoverElevation], [highlightElevation],
and [disabledElevation] parameters, if specified, must be non-negative.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="tooltip">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Text that describes the action that will occur when the button is pressed.</p><br/>
<p>This text is displayed when the user long-presses on the button and is
used for accessibility.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="foregroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The default foreground color for icons and text within the button.</p><br/>
<p>If this property is null, then the [FloatingActionButtonThemeData.foregroundColor]
of [ThemeData.floatingActionButtonTheme] is used. If that property is also
null, then the [ColorScheme.onPrimaryContainer] color of [ThemeData.colorScheme]
is used. If [ThemeData.useMaterial3] is set to false, then the
[ColorScheme.onSecondary] color of [ThemeData.colorScheme] is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="backgroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The button's background color.</p><br/>
<p>If this property is null, then the [FloatingActionButtonThemeData.backgroundColor]
of [ThemeData.floatingActionButtonTheme] is used. If that property is also
null, then the [ColorScheme.primaryContainer] color of [ThemeData.colorScheme]
is used. If [ThemeData.useMaterial3] is set to false, then the
[ColorScheme.secondary] color of [ThemeData.colorScheme] is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for filling the button when the button has input focus.</p><br/>
<p>In Material3, defaults to [ColorScheme.onPrimaryContainer] with opacity 0.1.
In Material 2, it defaults to [ThemeData.focusColor] for the current theme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hoverColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for filling the button when the button has a pointer
hovering over it.</p><br/>
<p>Defaults to [ThemeData.hoverColor] for the current theme in Material 2. In
Material 3, defaults to [ColorScheme.onPrimaryContainer] with opacity 0.08.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="splashColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The splash color for this [FloatingActionButton]'s [InkWell].</p><br/>
<p>If null, [FloatingActionButtonThemeData.splashColor] is used, if that is
null, [ThemeData.splashColor] is used in Material 2; [ColorScheme.onPrimaryContainer]
with opacity 0.1 is used in Material 3.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="heroTag">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The tag to apply to the button's [Hero] widget.</p><br/>
<p>Defaults to a tag that matches other floating action buttons.</p><br/>
<p>Set this to null explicitly if you don't want the floating action button to
have a hero tag.</p><br/>
<p>If this is not explicitly set, then there can only be one
[FloatingActionButton] per route (that is, per screen), since otherwise
there would be a tag conflict (multiple heroes on one route can't have the
same tag). The Material Design specification recommends only using one
floating action button per screen.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="elevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 6, the appropriate elevation for floating action buttons. The
value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the button has the input focus.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 8, the appropriate elevation for floating action buttons
while they have focus. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hoverElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the button is enabled and has a pointer hovering over it.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 8, the appropriate elevation for floating action buttons while
they have a pointer hovering over them. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="highlightElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the user is touching the button.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 12, the appropriate elevation for floating action buttons
while they are being touched. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="disabledElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button when the button is disabled
([onPressed] is null).</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to the same value as [elevation]. Setting this to zero makes the
floating action button work similar to an [ElevatedButton] but the titular
&quot;floating&quot; effect is lost. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onPressed">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The callback that is called when the button is tapped or otherwise activated.</p><br/>
<p>If this is set to null, the button will be disabled.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="mouseCursor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.RawMaterialButton.mouseCursor}</p><br/>
<p>If this property is null, [WidgetStateMouseCursor.clickable] will be used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shape">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The shape of the button's [Material].</p><br/>
<p>The button's highlight and splash are clipped to this shape. If the
button has an elevation, then its drop shadow is defined by this
shape as well.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="clipBehavior" type="ClipAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.Material.clipBehavior}</p><br/>
<p>Defaults to [Clip.none].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusNode">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.Focus.focusNode}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="autofocus" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.Focus.autofocus}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="materialTapTargetSize" type="MaterialTapTargetSizeAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Configures the minimum size of the tap target.</p><br/>
<p>Defaults to [ThemeData.materialTapTargetSize].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[MaterialTapTargetSize], for a description of how this affects tap targets.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="enableFeedback" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether detected gestures should provide acoustic and/or haptic feedback.</p><br/>
<p>For example, on Android a tap will produce a clicking sound and a
long-press will produce a short vibration, when feedback is enabled.</p><br/>
<p>If null, [FloatingActionButtonThemeData.enableFeedback] is used.
If both are null, then default value is true.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[Feedback] for providing platform-specific feedback to certain actions.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="FloatingActionButton.extended">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a wider [StadiumBorder]-shaped floating action button with
an optional [icon] and a [label].</p><br/>
<p>The [elevation], [highlightElevation], and [disabledElevation] parameters,
if specified, must be non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li><a href="https://m3.material.io/components/extended-fab">https://m3.material.io/components/extended-fab</a></li>
</ul>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="tooltip">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Text that describes the action that will occur when the button is pressed.</p><br/>
<p>This text is displayed when the user long-presses on the button and is
used for accessibility.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="foregroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The default foreground color for icons and text within the button.</p><br/>
<p>If this property is null, then the [FloatingActionButtonThemeData.foregroundColor]
of [ThemeData.floatingActionButtonTheme] is used. If that property is also
null, then the [ColorScheme.onPrimaryContainer] color of [ThemeData.colorScheme]
is used. If [ThemeData.useMaterial3] is set to false, then the
[ColorScheme.onSecondary] color of [ThemeData.colorScheme] is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="backgroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The button's background color.</p><br/>
<p>If this property is null, then the [FloatingActionButtonThemeData.backgroundColor]
of [ThemeData.floatingActionButtonTheme] is used. If that property is also
null, then the [ColorScheme.primaryContainer] color of [ThemeData.colorScheme]
is used. If [ThemeData.useMaterial3] is set to false, then the
[ColorScheme.secondary] color of [ThemeData.colorScheme] is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for filling the button when the button has input focus.</p><br/>
<p>In Material3, defaults to [ColorScheme.onPrimaryContainer] with opacity 0.1.
In Material 2, it defaults to [ThemeData.focusColor] for the current theme.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hoverColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for filling the button when the button has a pointer
hovering over it.</p><br/>
<p>Defaults to [ThemeData.hoverColor] for the current theme in Material 2. In
Material 3, defaults to [ColorScheme.onPrimaryContainer] with opacity 0.08.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="heroTag">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The tag to apply to the button's [Hero] widget.</p><br/>
<p>Defaults to a tag that matches other floating action buttons.</p><br/>
<p>Set this to null explicitly if you don't want the floating action button to
have a hero tag.</p><br/>
<p>If this is not explicitly set, then there can only be one
[FloatingActionButton] per route (that is, per screen), since otherwise
there would be a tag conflict (multiple heroes on one route can't have the
same tag). The Material Design specification recommends only using one
floating action button per screen.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="elevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 6, the appropriate elevation for floating action buttons. The
value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the button has the input focus.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 8, the appropriate elevation for floating action buttons
while they have focus. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hoverElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the button is enabled and has a pointer hovering over it.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 8, the appropriate elevation for floating action buttons while
they have a pointer hovering over them. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
<li>[disabledElevation], the elevation when the button is disabled.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="splashColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The splash color for this [FloatingActionButton]'s [InkWell].</p><br/>
<p>If null, [FloatingActionButtonThemeData.splashColor] is used, if that is
null, [ThemeData.splashColor] is used in Material 2; [ColorScheme.onPrimaryContainer]
with opacity 0.1 is used in Material 3.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="highlightElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button relative to its parent when
the user is touching the button.</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to 12, the appropriate elevation for floating action buttons
while they are being touched. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="disabledElevation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The z-coordinate at which to place this button when the button is disabled
([onPressed] is null).</p><br/>
<p>This controls the size of the shadow below the floating action button.</p><br/>
<p>Defaults to the same value as [elevation]. Setting this to zero makes the
floating action button work similar to an [ElevatedButton] but the titular
&quot;floating&quot; effect is lost. The value is always non-negative.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[elevation], the default elevation.</li>
<li>[highlightElevation], the elevation when the button is pressed.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onPressed">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The callback that is called when the button is tapped or otherwise activated.</p><br/>
<p>If this is set to null, the button will be disabled.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="mouseCursor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.RawMaterialButton.mouseCursor}</p><br/>
<p>If this property is null, [WidgetStateMouseCursor.clickable] will be used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shape">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The shape of the button's [Material].</p><br/>
<p>The button's highlight and splash are clipped to this shape. If the
button has an elevation, then its drop shadow is defined by this
shape as well.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="isExtended" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>True if this is an &quot;extended&quot; floating action button.</p><br/>
<p>Typically &quot;extended&quot; buttons have a [StadiumBorder] [shape]
and have been created with the [FloatingActionButton.extended]
constructor.</p><br/>
<p>The [Scaffold] animates the appearance of ordinary floating
action buttons with scale and rotation transitions. Extended
floating action buttons are scaled and faded in.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="materialTapTargetSize" type="MaterialTapTargetSizeAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Configures the minimum size of the tap target.</p><br/>
<p>Defaults to [ThemeData.materialTapTargetSize].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[MaterialTapTargetSize], for a description of how this affects tap targets.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="clipBehavior" type="ClipAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.Material.clipBehavior}</p><br/>
<p>Defaults to [Clip.none].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusNode">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.Focus.focusNode}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="autofocus" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.Focus.autofocus}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="extendedIconLabelSpacing">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The spacing between the icon and the label for an extended
[FloatingActionButton].</p><br/>
<p>If null, [FloatingActionButtonThemeData.extendedIconLabelSpacing] is used.
If that is also null, the default is 8.0.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="extendedPadding">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The padding for an extended [FloatingActionButton]'s content.</p><br/>
<p>If null, [FloatingActionButtonThemeData.extendedPadding] is used. If that
is also null, the default is
<code>EdgeInsetsDirectional.only(start: 16.0, end: 20.0)</code> if an icon is
provided, and <code>EdgeInsetsDirectional.only(start: 20.0, end: 20.0)</code> if not.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="extendedTextStyle">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The text style for an extended [FloatingActionButton]'s label.</p><br/>
<p>If null, [FloatingActionButtonThemeData.extendedTextStyle] is used. If
that is also null, then [TextTheme.labelLarge] with a letter spacing of 1.2
is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="icon"/>
                    <xs:attribute name="label"/>
                    <xs:attribute name="enableFeedback" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether detected gestures should provide acoustic and/or haptic feedback.</p><br/>
<p>For example, on Android a tap will produce a clicking sound and a
long-press will produce a short vibration, when feedback is enabled.</p><br/>
<p>If null, [FloatingActionButtonThemeData.enableFeedback] is used.
If both are null, then default value is true.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[Feedback] for providing platform-specific feedback to certain actions.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="Icon">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates an icon.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="icon">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The icon to display. The available icons are described in [Icons].</p><br/>
<p>The icon can be null, in which case the widget will render as an empty
space of the specified [size].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="size">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The size of the icon in logical pixels.</p><br/>
<p>Icons occupy a square with width and height equal to size.</p><br/>
<p>Defaults to the nearest [IconTheme]'s [IconThemeData.size].</p><br/>
<p>If this [Icon] is being placed inside an [IconButton], then use
[IconButton.iconSize] instead, so that the [IconButton] can make the splash
area the appropriate size as well. The [IconButton] uses an [IconTheme] to
pass down the size to the [Icon].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="fill">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The fill for drawing the icon.</p><br/>
<p>Requires the underlying icon font to support the <code>FILL</code> [FontVariation]
axis, otherwise has no effect. Variable font filenames often indicate
the supported axes. Must be between 0.0 (unfilled) and 1.0 (filled),
inclusive.</p><br/>
<p>Can be used to convey a state transition for animation or interaction.</p><br/>
<p>Defaults to nearest [IconTheme]'s [IconThemeData.fill].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[weight], for controlling stroke weight.</li>
<li>[grade], for controlling stroke weight in a more granular way.</li>
<li>[opticalSize], for controlling optical size.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="weight">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The stroke weight for drawing the icon.</p><br/>
<p>Requires the underlying icon font to support the <code>wght</code> [FontVariation]
axis, otherwise has no effect. Variable font filenames often indicate
the supported axes. Must be greater than 0.</p><br/>
<p>Defaults to nearest [IconTheme]'s [IconThemeData.weight].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[fill], for controlling fill.</li>
<li>[grade], for controlling stroke weight in a more granular way.</li>
<li>[opticalSize], for controlling optical size.</li>
<li>https://fonts.google.com/knowledge/glossary/weight_axis</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="grade">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The grade (granular stroke weight) for drawing the icon.</p><br/>
<p>Requires the underlying icon font to support the <code>GRAD</code> [FontVariation]
axis, otherwise has no effect. Variable font filenames often indicate
the supported axes. Can be negative.</p><br/>
<p>Grade and [weight] both affect a symbol's stroke weight (thickness), but
grade has a smaller impact on the size of the symbol.</p><br/>
<p>Grade is also available in some text fonts. One can match grade levels
between text and symbols for a harmonious visual effect. For example, if
the text font has a -25 grade value, the symbols can match it with a
suitable value, say -25.</p><br/>
<p>Defaults to nearest [IconTheme]'s [IconThemeData.grade].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[fill], for controlling fill.</li>
<li>[weight], for controlling stroke weight in a less granular way.</li>
<li>[opticalSize], for controlling optical size.</li>
<li>https://fonts.google.com/knowledge/glossary/grade_axis</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="opticalSize">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The optical size for drawing the icon.</p><br/>
<p>Requires the underlying icon font to support the <code>opsz</code> [FontVariation]
axis, otherwise has no effect. Variable font filenames often indicate
the supported axes. Must be greater than 0.</p><br/>
<p>For an icon to look the same at different sizes, the stroke weight
(thickness) must change as the icon size scales. Optical size offers a way
to automatically adjust the stroke weight as icon size changes.</p><br/>
<p>Defaults to nearest [IconTheme]'s [IconThemeData.opticalSize].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[fill], for controlling fill.</li>
<li>[weight], for controlling stroke weight.</li>
<li>[grade], for controlling stroke weight in a more granular way.</li>
<li>https://fonts.google.com/knowledge/glossary/optical_size_axis</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="color">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use when drawing the icon.</p><br/>
<p>Defaults to the nearest [IconTheme]'s [IconThemeData.color].</p><br/>
<p>The color (whether specified explicitly here or obtained from the
[IconTheme]) will be further adjusted by the nearest [IconTheme]'s
[IconThemeData.opacity].</p><br/>
<p>{@tool snippet}
Typically, a Material Design color will be used, as follows:</p><br/>
<pre><code class="language-dart">Icon(
  Icons.widgets,
  color: Colors.blue.shade400,
)
</code></pre>
<p>{@end-tool}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shadows">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A list of [Shadow]s that will be painted underneath the icon.</p><br/>
<p>Multiple shadows are supported to replicate lighting from multiple light
sources.</p><br/>
<p>Shadows must be in the same order for [Icon] to be considered as
equivalent as order produces differing transparency.</p><br/>
<p>Defaults to the nearest [IconTheme]'s [IconThemeData.shadows].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="semanticLabel">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Semantic label for the icon.</p><br/>
<p>Announced by assistive technologies (e.g TalkBack/VoiceOver).
This label does not show in the UI.</p><br/>
<ul>
<li>[SemanticsProperties.label], which is set to [semanticLabel] in the
underlying	 [Semantics] widget.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textDirection" type="TextDirectionAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The text direction to use for rendering the icon.</p><br/>
<p>If this is null, the ambient [Directionality] is used instead.</p><br/>
<p>Some icons follow the reading direction. For example, &quot;back&quot; buttons point
left in left-to-right environments and right in right-to-left
environments. Such icons have their [IconData.matchTextDirection] field
set to true, and the [Icon] widget uses the [textDirection] to determine
the orientation in which to draw the icon.</p><br/>
<p>This property has no effect if the [icon]'s [IconData.matchTextDirection]
field is false, but for consistency a text direction value must always be
specified, either directly using this property or using [Directionality].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="applyTextScaling" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether to scale the size of this widget using the ambient [MediaQuery]'s [TextScaler].</p><br/>
<p>This is specially useful when you have an icon associated with a text, as
scaling the text without scaling the icon would result in a confusing
interface.</p><br/>
<p>Defaults to the nearest [IconTheme]'s
[IconThemeData.applyTextScaling].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="blendMode" type="BlendModeAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The [BlendMode] to apply to the foreground of the icon.</p><br/>
<p>Defaults to [BlendMode.srcOver]</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="fontWeight" type="FontWeightAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The typeface thickness to use when painting the text (e.g., bold).</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="MaterialApp">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a MaterialApp.</p><br/>
<p>At least one of [home], [routes], [onGenerateRoute], or [builder] must be
non-null. If only [routes] is given, it must include an entry for the
[Navigator.defaultRouteName] (<code>/</code>), since that is the route used when the
application is launched with an intent that specifies an otherwise
unsupported route.</p><br/>
<p>This class creates an instance of [WidgetsApp].</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="navigatorKey">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.navigatorKey}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="scaffoldMessengerKey">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A key to use when building the [ScaffoldMessenger].</p><br/>
<p>If a [scaffoldMessengerKey] is specified, the [ScaffoldMessenger] can be
directly manipulated without first obtaining it from a [BuildContext] via
[ScaffoldMessenger.of]: from the [scaffoldMessengerKey], use the
[GlobalKey.currentState] getter.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="home">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.home}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="routes">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The application's top-level routing table.</p><br/>
<p>When a named route is pushed with [Navigator.pushNamed], the route name is
looked up in this map. If the name is present, the associated
[WidgetBuilder] is used to construct a [MaterialPageRoute] that
performs an appropriate transition, including [Hero] animations, to the
new route.</p><br/>
<p>{@macro flutter.widgets.widgetsApp.routes}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="initialRoute">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.initialRoute}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onGenerateRoute">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.onGenerateRoute}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onGenerateInitialRoutes">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.onGenerateInitialRoutes}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onUnknownRoute">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.onUnknownRoute}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onNavigationNotification">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.onNavigationNotification}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="navigatorObservers">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.navigatorObservers}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="builder">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.builder}</p><br/>
<p>Material specific features such as [showDialog] and [showMenu], and widgets
such as [Tooltip], [PopupMenuButton], also require a [Navigator] to properly
function.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="title">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.title}</p><br/>
<p>This value is passed unmodified to [WidgetsApp.title].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onGenerateTitle">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.onGenerateTitle}</p><br/>
<p>This value is passed unmodified to [WidgetsApp.onGenerateTitle].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="color">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.color}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="theme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Default visual properties, like colors fonts and shapes, for this app's
material widgets.</p><br/>
<p>A second [darkTheme] [ThemeData] value, which is used to provide a dark
version of the user interface can also be specified. [themeMode] will
control which theme will be used if a [darkTheme] is provided.</p><br/>
<p>The default value of this property is the value of [ThemeData.light()].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[themeMode], which controls which theme to use.</li>
<li>[MediaQueryData.platformBrightness], which indicates the platform's
desired brightness and is used to automatically toggle between [theme]
and [darkTheme] in [MaterialApp].</li>
<li>[ThemeData.brightness], which indicates the [Brightness] of a theme's
colors.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="darkTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The [ThemeData] to use when a 'dark mode' is requested by the system.</p><br/>
<p>Some host platforms allow the users to select a system-wide 'dark mode',
or the application may want to offer the user the ability to choose a
dark theme just for this application. This is theme that will be used for
such cases. [themeMode] will control which theme will be used.</p><br/>
<p>This theme should have a [ThemeData.brightness] set to [Brightness.dark].</p><br/>
<p>Uses [theme] instead when null. Defaults to the value of
[ThemeData.light()] when both [darkTheme] and [theme] are null.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[themeMode], which controls which theme to use.</li>
<li>[MediaQueryData.platformBrightness], which indicates the platform's
desired brightness and is used to automatically toggle between [theme]
and [darkTheme] in [MaterialApp].</li>
<li>[ThemeData.brightness], which is typically set to the value of
[MediaQueryData.platformBrightness].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="highContrastTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The [ThemeData] to use when 'high contrast' is requested by the system.</p><br/>
<p>Some host platforms (for example, iOS) allow the users to increase
contrast through an accessibility setting.</p><br/>
<p>Uses [theme] instead when null.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[MediaQueryData.highContrast], which indicates the platform's
desire to increase contrast.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="highContrastDarkTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The [ThemeData] to use when a 'dark mode' and 'high contrast' is requested
by the system.</p><br/>
<p>Some host platforms (for example, iOS) allow the users to increase
contrast through an accessibility setting.</p><br/>
<p>This theme should have a [ThemeData.brightness] set to [Brightness.dark].</p><br/>
<p>Uses [darkTheme] instead when null.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[MediaQueryData.highContrast], which indicates the platform's
desire to increase contrast.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="themeMode" type="ThemeModeAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Determines which theme will be used by the application if both [theme]
and [darkTheme] are provided.</p><br/>
<p>If set to [ThemeMode.system], the choice of which theme to use will
be based on the user's system preferences. If the [MediaQuery.platformBrightnessOf]
is [Brightness.light], [theme] will be used. If it is [Brightness.dark],
[darkTheme] will be used (unless it is null, in which case [theme]
will be used.</p><br/>
<p>If set to [ThemeMode.light] the [theme] will always be used,
regardless of the user's system preference.</p><br/>
<p>If set to [ThemeMode.dark] the [darkTheme] will be used
regardless of the user's system preference. If [darkTheme] is null
then it will fallback to using [theme].</p><br/>
<p>The default value is [ThemeMode.system].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[theme], which is used when a light mode is selected.</li>
<li>[darkTheme], which is used when a dark mode is selected.</li>
<li>[ThemeData.brightness], which indicates to various parts of the
system what kind of theme is being used.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="themeAnimationDuration">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The duration of animated theme changes.</p><br/>
<p>When the theme changes (either by the [theme], [darkTheme] or [themeMode]
parameters changing) it is animated to the new theme over time.
The [themeAnimationDuration] determines how long this animation takes.</p><br/>
<p>To have the theme change immediately, you can set this to [Duration.zero].</p><br/>
<p>The default is [kThemeAnimationDuration].</p><br/>
<p>See also:
[themeAnimationCurve], which defines the curve used for the animation.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="themeAnimationCurve" type="CurvesAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The curve to apply when animating theme changes.</p><br/>
<p>The default is [Curves.linear].</p><br/>
<p>This is ignored if [themeAnimationDuration] is [Duration.zero].</p><br/>
<p>See also:
[themeAnimationDuration], which defines how long the animation is.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="locale">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.locale}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localizationsDelegates">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.localizationsDelegates}</p><br/>
<p>Internationalized apps that require translations for one of the locales
listed in [GlobalMaterialLocalizations] should specify this parameter
and list the [supportedLocales] that the application can handle.</p><br/>
<pre><code class="language-dart">// The GlobalMaterialLocalizations and GlobalWidgetsLocalizations
// classes require the following import:
// import 'package:flutter_localizations/flutter_localizations.dart';

const MaterialApp(
  localizationsDelegates: &lt;LocalizationsDelegate&lt;Object&gt;&gt;[
    // ... app-specific localization delegate(s) here
    GlobalMaterialLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
  ],
  supportedLocales: &lt;Locale&gt;[
    Locale('en', 'US'), // English
    Locale('he', 'IL'), // Hebrew
    // ... other locales the app supports
  ],
  // ...
)
</code></pre>
<h2>Adding localizations for a new locale</h2>
<p>The information that follows applies to the unusual case of an app
adding translations for a language not already supported by
[GlobalMaterialLocalizations].</p><br/>
<p>Delegates that produce [WidgetsLocalizations] and [MaterialLocalizations]
are included automatically. Apps can provide their own versions of these
localizations by creating implementations of
[LocalizationsDelegate&lt;WidgetsLocalizations&gt;] or
[LocalizationsDelegate&lt;MaterialLocalizations&gt;] whose load methods return
custom versions of [WidgetsLocalizations] or [MaterialLocalizations].</p><br/>
<p>For example: to add support to [MaterialLocalizations] for a locale it
doesn't already support, say <code>const Locale('foo', 'BR')</code>, one first
creates a subclass of [MaterialLocalizations] that provides the
translations:</p><br/>
<pre><code class="language-dart">class FooLocalizations extends MaterialLocalizations {
  FooLocalizations();
  @override
  String get okButtonLabel =&gt; 'foo';
  // ...
  // lots of other getters and methods to override!
}
</code></pre>
<p>One must then create a [LocalizationsDelegate] subclass that can provide
an instance of the [MaterialLocalizations] subclass. In this case, this is
essentially just a method that constructs a <code>FooLocalizations</code> object. A
[SynchronousFuture] is used here because no asynchronous work takes place
upon &quot;loading&quot; the localizations object.</p><br/>
<pre><code class="language-dart">// continuing from previous example...
class FooLocalizationsDelegate extends LocalizationsDelegate&lt;MaterialLocalizations&gt; {
  const FooLocalizationsDelegate();
  @override
  bool isSupported(Locale locale) {
    return locale == const Locale('foo', 'BR');
  }
  @override
  Future&lt;FooLocalizations&gt; load(Locale locale) {
    assert(locale == const Locale('foo', 'BR'));
    return SynchronousFuture&lt;FooLocalizations&gt;(FooLocalizations());
  }
  @override
  bool shouldReload(FooLocalizationsDelegate old) =&gt; false;
}
</code></pre>
<p>Constructing a [MaterialApp] with a <code>FooLocalizationsDelegate</code> overrides
the automatically included delegate for [MaterialLocalizations] because
only the first delegate of each [LocalizationsDelegate.type] is used and
the automatically included delegates are added to the end of the app's
[localizationsDelegates] list.</p><br/>
<pre><code class="language-dart">// continuing from previous example...
const MaterialApp(
  localizationsDelegates: &lt;LocalizationsDelegate&lt;Object&gt;&gt;[
    FooLocalizationsDelegate(),
  ],
  // ...
)
</code></pre>
<p>See also:</p><br/>
<ul>
<li>[supportedLocales], which must be specified along with
[localizationsDelegates].</li>
<li>[GlobalMaterialLocalizations], a [localizationsDelegates] value
which provides material localizations for many languages.</li>
<li>The Flutter Internationalization Tutorial,
<a href="https://flutter.dev/to/internationalization/">https://flutter.dev/to/internationalization/</a>.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localeListResolutionCallback">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.localeListResolutionCallback}</p><br/>
<p>This callback is passed along to the [WidgetsApp] built by this widget.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localeResolutionCallback">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.LocaleResolutionCallback}</p><br/>
<p>This callback is passed along to the [WidgetsApp] built by this widget.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="supportedLocales">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.supportedLocales}</p><br/>
<p>It is passed along unmodified to the [WidgetsApp] built by this widget.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[localizationsDelegates], which must be specified for localized
applications.</li>
<li>[GlobalMaterialLocalizations], a [localizationsDelegates] value
which provides material localizations for many languages.</li>
<li>The Flutter Internationalization Tutorial,
<a href="https://flutter.dev/to/internationalization/">https://flutter.dev/to/internationalization/</a>.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="debugShowMaterialGrid" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Turns on a [GridPaper] overlay that paints a baseline grid
Material apps.</p><br/>
<p>Only available in debug mode.</p><br/>
<p>See also:</p><br/>
<ul>
<li><a href="https://material.io/design/layout/spacing-methods.html">https://material.io/design/layout/spacing-methods.html</a></li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showPerformanceOverlay" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Turns on a performance overlay.</p><br/>
<p>See also:</p><br/>
<ul>
<li><a href="https://flutter.dev/to/performance-overlay">https://flutter.dev/to/performance-overlay</a></li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="checkerboardRasterCacheImages" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Turns on checkerboarding of raster cache images.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="checkerboardOffscreenLayers" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Turns on checkerboarding of layers rendered to offscreen bitmaps.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showSemanticsDebugger" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Turns on an overlay that shows the accessibility information
reported by the framework.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="debugShowCheckedModeBanner" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.debugShowCheckedModeBanner}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shortcuts">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.shortcuts}
{@tool snippet}
This example shows how to add a single shortcut for
[LogicalKeyboardKey.select] to the default shortcuts without needing to
add your own [Shortcuts] widget.</p><br/>
<p>Alternatively, you could insert a [Shortcuts] widget with just the mapping
you want to add between the [WidgetsApp] and its child and get the same
effect.</p><br/>
<pre><code class="language-dart">Widget build(BuildContext context) {
  return WidgetsApp(
    shortcuts: &lt;ShortcutActivator, Intent&gt;{
      ... WidgetsApp.defaultShortcuts,
      const SingleActivator(LogicalKeyboardKey.select): const ActivateIntent(),
    },
    color: const Color(0xFFFF0000),
    builder: (BuildContext context, Widget? child) {
      return const Placeholder();
    },
  );
}
</code></pre>
<p>{@end-tool}
{@macro flutter.widgets.widgetsApp.shortcuts.seeAlso}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="actions">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.actions}
{@tool snippet}
This example shows how to add a single action handling an
[ActivateAction] to the default actions without needing to
add your own [Actions] widget.</p><br/>
<p>Alternatively, you could insert a [Actions] widget with just the mapping
you want to add between the [WidgetsApp] and its child and get the same
effect.</p><br/>
<pre><code class="language-dart">Widget build(BuildContext context) {
  return WidgetsApp(
    actions: &lt;Type, Action&lt;Intent&gt;&gt;{
      ... WidgetsApp.defaultActions,
      ActivateAction: CallbackAction&lt;Intent&gt;(
        onInvoke: (Intent intent) {
          // Do something here...
          return null;
        },
      ),
    },
    color: const Color(0xFFFF0000),
    builder: (BuildContext context, Widget? child) {
      return const Placeholder();
    },
  );
}
</code></pre>
<p>{@end-tool}
{@macro flutter.widgets.widgetsApp.actions.seeAlso}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="restorationScopeId">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.restorationScopeId}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="scrollBehavior">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.materialApp.scrollBehavior}
The default [ScrollBehavior] for the application.</p><br/>
<p>[ScrollBehavior]s describe how [Scrollable] widgets behave. Providing
a [ScrollBehavior] can set the default [ScrollPhysics] across
an application, and manage [Scrollable] decorations like [Scrollbar]s and
[GlowingOverscrollIndicator]s.
{@endtemplate}</p><br/>
<p>When null, defaults to [MaterialScrollBehavior].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[ScrollConfiguration], which controls how [Scrollable] widgets behave
in a subtree.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="themeAnimationStyle">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Used to override the theme animation curve and duration.</p><br/>
<p>If [AnimationStyle.duration] is provided, it will be used to override
the theme animation duration in the underlying [AnimatedTheme] widget.
If it is null, then [themeAnimationDuration] will be used. Otherwise,
defaults to 200ms.</p><br/>
<p>If [AnimationStyle.curve] is provided, it will be used to override
the theme animation curve in the underlying [AnimatedTheme] widget.
If it is null, then [themeAnimationCurve] will be used. Otherwise,
defaults to [Curves.linear].</p><br/>
<p>To disable the theme animation, use [AnimationStyle.noAnimation].</p><br/>
<p>{@tool dartpad}
This sample showcases how to override the theme animation curve and
duration in the [MaterialApp] widget using [AnimationStyle].</p><br/>
<p>** See code in examples/api/lib/material/app/app.0.dart **
{@end-tool}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="MaterialApp.router">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a [MaterialApp] that uses the [Router] instead of a [Navigator].</p><br/>
<p>{@macro flutter.widgets.WidgetsApp.router}</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="scaffoldMessengerKey">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A key to use when building the [ScaffoldMessenger].</p><br/>
<p>If a [scaffoldMessengerKey] is specified, the [ScaffoldMessenger] can be
directly manipulated without first obtaining it from a [BuildContext] via
[ScaffoldMessenger.of]: from the [scaffoldMessengerKey], use the
[GlobalKey.currentState] getter.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="routeInformationProvider">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.routeInformationProvider}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="routeInformationParser">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.routeInformationParser}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="routerDelegate">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.routerDelegate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="routerConfig">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.routerConfig}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="backButtonDispatcher">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.backButtonDispatcher}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="builder">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.builder}</p><br/>
<p>Material specific features such as [showDialog] and [showMenu], and widgets
such as [Tooltip], [PopupMenuButton], also require a [Navigator] to properly
function.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="title">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.title}</p><br/>
<p>This value is passed unmodified to [WidgetsApp.title].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onGenerateTitle">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.onGenerateTitle}</p><br/>
<p>This value is passed unmodified to [WidgetsApp.onGenerateTitle].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onNavigationNotification">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.onNavigationNotification}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="color">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.color}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="theme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Default visual properties, like colors fonts and shapes, for this app's
material widgets.</p><br/>
<p>A second [darkTheme] [ThemeData] value, which is used to provide a dark
version of the user interface can also be specified. [themeMode] will
control which theme will be used if a [darkTheme] is provided.</p><br/>
<p>The default value of this property is the value of [ThemeData.light()].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[themeMode], which controls which theme to use.</li>
<li>[MediaQueryData.platformBrightness], which indicates the platform's
desired brightness and is used to automatically toggle between [theme]
and [darkTheme] in [MaterialApp].</li>
<li>[ThemeData.brightness], which indicates the [Brightness] of a theme's
colors.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="darkTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The [ThemeData] to use when a 'dark mode' is requested by the system.</p><br/>
<p>Some host platforms allow the users to select a system-wide 'dark mode',
or the application may want to offer the user the ability to choose a
dark theme just for this application. This is theme that will be used for
such cases. [themeMode] will control which theme will be used.</p><br/>
<p>This theme should have a [ThemeData.brightness] set to [Brightness.dark].</p><br/>
<p>Uses [theme] instead when null. Defaults to the value of
[ThemeData.light()] when both [darkTheme] and [theme] are null.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[themeMode], which controls which theme to use.</li>
<li>[MediaQueryData.platformBrightness], which indicates the platform's
desired brightness and is used to automatically toggle between [theme]
and [darkTheme] in [MaterialApp].</li>
<li>[ThemeData.brightness], which is typically set to the value of
[MediaQueryData.platformBrightness].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="highContrastTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The [ThemeData] to use when 'high contrast' is requested by the system.</p><br/>
<p>Some host platforms (for example, iOS) allow the users to increase
contrast through an accessibility setting.</p><br/>
<p>Uses [theme] instead when null.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[MediaQueryData.highContrast], which indicates the platform's
desire to increase contrast.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="highContrastDarkTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The [ThemeData] to use when a 'dark mode' and 'high contrast' is requested
by the system.</p><br/>
<p>Some host platforms (for example, iOS) allow the users to increase
contrast through an accessibility setting.</p><br/>
<p>This theme should have a [ThemeData.brightness] set to [Brightness.dark].</p><br/>
<p>Uses [darkTheme] instead when null.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[MediaQueryData.highContrast], which indicates the platform's
desire to increase contrast.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="themeMode" type="ThemeModeAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Determines which theme will be used by the application if both [theme]
and [darkTheme] are provided.</p><br/>
<p>If set to [ThemeMode.system], the choice of which theme to use will
be based on the user's system preferences. If the [MediaQuery.platformBrightnessOf]
is [Brightness.light], [theme] will be used. If it is [Brightness.dark],
[darkTheme] will be used (unless it is null, in which case [theme]
will be used.</p><br/>
<p>If set to [ThemeMode.light] the [theme] will always be used,
regardless of the user's system preference.</p><br/>
<p>If set to [ThemeMode.dark] the [darkTheme] will be used
regardless of the user's system preference. If [darkTheme] is null
then it will fallback to using [theme].</p><br/>
<p>The default value is [ThemeMode.system].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[theme], which is used when a light mode is selected.</li>
<li>[darkTheme], which is used when a dark mode is selected.</li>
<li>[ThemeData.brightness], which indicates to various parts of the
system what kind of theme is being used.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="themeAnimationDuration">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The duration of animated theme changes.</p><br/>
<p>When the theme changes (either by the [theme], [darkTheme] or [themeMode]
parameters changing) it is animated to the new theme over time.
The [themeAnimationDuration] determines how long this animation takes.</p><br/>
<p>To have the theme change immediately, you can set this to [Duration.zero].</p><br/>
<p>The default is [kThemeAnimationDuration].</p><br/>
<p>See also:
[themeAnimationCurve], which defines the curve used for the animation.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="themeAnimationCurve" type="CurvesAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The curve to apply when animating theme changes.</p><br/>
<p>The default is [Curves.linear].</p><br/>
<p>This is ignored if [themeAnimationDuration] is [Duration.zero].</p><br/>
<p>See also:
[themeAnimationDuration], which defines how long the animation is.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="locale">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.locale}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localizationsDelegates">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.localizationsDelegates}</p><br/>
<p>Internationalized apps that require translations for one of the locales
listed in [GlobalMaterialLocalizations] should specify this parameter
and list the [supportedLocales] that the application can handle.</p><br/>
<pre><code class="language-dart">// The GlobalMaterialLocalizations and GlobalWidgetsLocalizations
// classes require the following import:
// import 'package:flutter_localizations/flutter_localizations.dart';

const MaterialApp(
  localizationsDelegates: &lt;LocalizationsDelegate&lt;Object&gt;&gt;[
    // ... app-specific localization delegate(s) here
    GlobalMaterialLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
  ],
  supportedLocales: &lt;Locale&gt;[
    Locale('en', 'US'), // English
    Locale('he', 'IL'), // Hebrew
    // ... other locales the app supports
  ],
  // ...
)
</code></pre>
<h2>Adding localizations for a new locale</h2>
<p>The information that follows applies to the unusual case of an app
adding translations for a language not already supported by
[GlobalMaterialLocalizations].</p><br/>
<p>Delegates that produce [WidgetsLocalizations] and [MaterialLocalizations]
are included automatically. Apps can provide their own versions of these
localizations by creating implementations of
[LocalizationsDelegate&lt;WidgetsLocalizations&gt;] or
[LocalizationsDelegate&lt;MaterialLocalizations&gt;] whose load methods return
custom versions of [WidgetsLocalizations] or [MaterialLocalizations].</p><br/>
<p>For example: to add support to [MaterialLocalizations] for a locale it
doesn't already support, say <code>const Locale('foo', 'BR')</code>, one first
creates a subclass of [MaterialLocalizations] that provides the
translations:</p><br/>
<pre><code class="language-dart">class FooLocalizations extends MaterialLocalizations {
  FooLocalizations();
  @override
  String get okButtonLabel =&gt; 'foo';
  // ...
  // lots of other getters and methods to override!
}
</code></pre>
<p>One must then create a [LocalizationsDelegate] subclass that can provide
an instance of the [MaterialLocalizations] subclass. In this case, this is
essentially just a method that constructs a <code>FooLocalizations</code> object. A
[SynchronousFuture] is used here because no asynchronous work takes place
upon &quot;loading&quot; the localizations object.</p><br/>
<pre><code class="language-dart">// continuing from previous example...
class FooLocalizationsDelegate extends LocalizationsDelegate&lt;MaterialLocalizations&gt; {
  const FooLocalizationsDelegate();
  @override
  bool isSupported(Locale locale) {
    return locale == const Locale('foo', 'BR');
  }
  @override
  Future&lt;FooLocalizations&gt; load(Locale locale) {
    assert(locale == const Locale('foo', 'BR'));
    return SynchronousFuture&lt;FooLocalizations&gt;(FooLocalizations());
  }
  @override
  bool shouldReload(FooLocalizationsDelegate old) =&gt; false;
}
</code></pre>
<p>Constructing a [MaterialApp] with a <code>FooLocalizationsDelegate</code> overrides
the automatically included delegate for [MaterialLocalizations] because
only the first delegate of each [LocalizationsDelegate.type] is used and
the automatically included delegates are added to the end of the app's
[localizationsDelegates] list.</p><br/>
<pre><code class="language-dart">// continuing from previous example...
const MaterialApp(
  localizationsDelegates: &lt;LocalizationsDelegate&lt;Object&gt;&gt;[
    FooLocalizationsDelegate(),
  ],
  // ...
)
</code></pre>
<p>See also:</p><br/>
<ul>
<li>[supportedLocales], which must be specified along with
[localizationsDelegates].</li>
<li>[GlobalMaterialLocalizations], a [localizationsDelegates] value
which provides material localizations for many languages.</li>
<li>The Flutter Internationalization Tutorial,
<a href="https://flutter.dev/to/internationalization/">https://flutter.dev/to/internationalization/</a>.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localeListResolutionCallback">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.localeListResolutionCallback}</p><br/>
<p>This callback is passed along to the [WidgetsApp] built by this widget.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localeResolutionCallback">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.LocaleResolutionCallback}</p><br/>
<p>This callback is passed along to the [WidgetsApp] built by this widget.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="supportedLocales">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.supportedLocales}</p><br/>
<p>It is passed along unmodified to the [WidgetsApp] built by this widget.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[localizationsDelegates], which must be specified for localized
applications.</li>
<li>[GlobalMaterialLocalizations], a [localizationsDelegates] value
which provides material localizations for many languages.</li>
<li>The Flutter Internationalization Tutorial,
<a href="https://flutter.dev/to/internationalization/">https://flutter.dev/to/internationalization/</a>.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="debugShowMaterialGrid" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Turns on a [GridPaper] overlay that paints a baseline grid
Material apps.</p><br/>
<p>Only available in debug mode.</p><br/>
<p>See also:</p><br/>
<ul>
<li><a href="https://material.io/design/layout/spacing-methods.html">https://material.io/design/layout/spacing-methods.html</a></li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showPerformanceOverlay" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Turns on a performance overlay.</p><br/>
<p>See also:</p><br/>
<ul>
<li><a href="https://flutter.dev/to/performance-overlay">https://flutter.dev/to/performance-overlay</a></li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="checkerboardRasterCacheImages" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Turns on checkerboarding of raster cache images.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="checkerboardOffscreenLayers" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Turns on checkerboarding of layers rendered to offscreen bitmaps.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="showSemanticsDebugger" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Turns on an overlay that shows the accessibility information
reported by the framework.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="debugShowCheckedModeBanner" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.debugShowCheckedModeBanner}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shortcuts">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.shortcuts}
{@tool snippet}
This example shows how to add a single shortcut for
[LogicalKeyboardKey.select] to the default shortcuts without needing to
add your own [Shortcuts] widget.</p><br/>
<p>Alternatively, you could insert a [Shortcuts] widget with just the mapping
you want to add between the [WidgetsApp] and its child and get the same
effect.</p><br/>
<pre><code class="language-dart">Widget build(BuildContext context) {
  return WidgetsApp(
    shortcuts: &lt;ShortcutActivator, Intent&gt;{
      ... WidgetsApp.defaultShortcuts,
      const SingleActivator(LogicalKeyboardKey.select): const ActivateIntent(),
    },
    color: const Color(0xFFFF0000),
    builder: (BuildContext context, Widget? child) {
      return const Placeholder();
    },
  );
}
</code></pre>
<p>{@end-tool}
{@macro flutter.widgets.widgetsApp.shortcuts.seeAlso}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="actions">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.actions}
{@tool snippet}
This example shows how to add a single action handling an
[ActivateAction] to the default actions without needing to
add your own [Actions] widget.</p><br/>
<p>Alternatively, you could insert a [Actions] widget with just the mapping
you want to add between the [WidgetsApp] and its child and get the same
effect.</p><br/>
<pre><code class="language-dart">Widget build(BuildContext context) {
  return WidgetsApp(
    actions: &lt;Type, Action&lt;Intent&gt;&gt;{
      ... WidgetsApp.defaultActions,
      ActivateAction: CallbackAction&lt;Intent&gt;(
        onInvoke: (Intent intent) {
          // Do something here...
          return null;
        },
      ),
    },
    color: const Color(0xFFFF0000),
    builder: (BuildContext context, Widget? child) {
      return const Placeholder();
    },
  );
}
</code></pre>
<p>{@end-tool}
{@macro flutter.widgets.widgetsApp.actions.seeAlso}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="restorationScopeId">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.widgets.widgetsApp.restorationScopeId}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="scrollBehavior">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.material.materialApp.scrollBehavior}
The default [ScrollBehavior] for the application.</p><br/>
<p>[ScrollBehavior]s describe how [Scrollable] widgets behave. Providing
a [ScrollBehavior] can set the default [ScrollPhysics] across
an application, and manage [Scrollable] decorations like [Scrollbar]s and
[GlowingOverscrollIndicator]s.
{@endtemplate}</p><br/>
<p>When null, defaults to [MaterialScrollBehavior].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[ScrollConfiguration], which controls how [Scrollable] widgets behave
in a subtree.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="themeAnimationStyle">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Used to override the theme animation curve and duration.</p><br/>
<p>If [AnimationStyle.duration] is provided, it will be used to override
the theme animation duration in the underlying [AnimatedTheme] widget.
If it is null, then [themeAnimationDuration] will be used. Otherwise,
defaults to 200ms.</p><br/>
<p>If [AnimationStyle.curve] is provided, it will be used to override
the theme animation curve in the underlying [AnimatedTheme] widget.
If it is null, then [themeAnimationCurve] will be used. Otherwise,
defaults to [Curves.linear].</p><br/>
<p>To disable the theme animation, use [AnimationStyle.noAnimation].</p><br/>
<p>{@tool dartpad}
This sample showcases how to override the theme animation curve and
duration in the [MaterialApp] widget using [AnimationStyle].</p><br/>
<p>** See code in examples/api/lib/material/app/app.0.dart **
{@end-tool}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="Scaffold">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a visual scaffold for Material Design widgets.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="appBar">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An app bar to display at the top of the scaffold.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="body">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The primary content of the scaffold.</p><br/>
<p>Displayed below the [appBar], above the bottom of the ambient
[MediaQuery]'s [MediaQueryData.viewInsets], and behind the
[floatingActionButton] and [drawer]. If [resizeToAvoidBottomInset] is
false then the body is not resized when the onscreen keyboard appears,
i.e. it is not inset by <code>viewInsets.bottom</code>.</p><br/>
<p>The widget in the body of the scaffold is positioned at the top-left of
the available space between the app bar and the bottom of the scaffold. To
center this widget instead, consider putting it in a [Center] widget and
having that be the body. To expand this widget instead, consider
putting it in a [SizedBox.expand].</p><br/>
<p>If you have a column of widgets that should normally fit on the screen,
but may overflow and would in such cases need to scroll, consider using a
[ListView] as the body of the scaffold. This is also a good choice for
the case where your body is a scrollable list.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="floatingActionButton">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A button displayed floating above [body], in the bottom right corner.</p><br/>
<p>Typically a [FloatingActionButton].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="floatingActionButtonLocation">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Responsible for determining where the [floatingActionButton] should go.</p><br/>
<p>If null, the [ScaffoldState] will use the default location, [FloatingActionButtonLocation.endFloat].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="floatingActionButtonAnimator">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Animator to move the [floatingActionButton] to a new [floatingActionButtonLocation].</p><br/>
<p>If null, the [ScaffoldState] will use the default animator, [FloatingActionButtonAnimator.scaling].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="persistentFooterButtons">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A set of buttons that are displayed at the bottom of the scaffold.</p><br/>
<p>Typically this is a list of [TextButton] widgets. These buttons are
persistently visible, even if the [body] of the scaffold scrolls.</p><br/>
<p>These widgets will be wrapped in an [OverflowBar].</p><br/>
<p>The [persistentFooterButtons] are rendered above the
[bottomNavigationBar] but below the [body].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="persistentFooterAlignment" type="AlignmentDirectionalAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The alignment of the [persistentFooterButtons] inside the [OverflowBar].</p><br/>
<p>Defaults to [AlignmentDirectional.centerEnd].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="persistentFooterDecoration">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Decoration for the container that holds the [persistentFooterButtons].</p><br/>
<p>By default, this container has a top border with a width of 1.0, created by
[Divider.createBorderSide].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[persistentFooterButtons], which defines the buttons to show in the footer.</li>
<li>[persistentFooterAlignment], which defines the alignment of the footer buttons.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="drawer">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A panel displayed to the side of the [body], often hidden on mobile
devices. Swipes in from either left-to-right ([TextDirection.ltr]) or
right-to-left ([TextDirection.rtl])</p><br/>
<p>Typically a [Drawer].</p><br/>
<p>To open the drawer, use the [ScaffoldState.openDrawer] function.</p><br/>
<p>To close the drawer, use either [ScaffoldState.closeDrawer], [Navigator.pop]
or press the escape key on the keyboard.</p><br/>
<p>{@tool dartpad}
To disable the drawer edge swipe on mobile, set the
[Scaffold.drawerEnableOpenDragGesture] to false. Then, use
[ScaffoldState.openDrawer] to open the drawer and [Navigator.pop] to close
it.</p><br/>
<p>** See code in examples/api/lib/material/scaffold/scaffold.drawer.0.dart **
{@end-tool}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onDrawerChanged">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Optional callback that is called when the [Scaffold.drawer] is opened or closed.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="endDrawer">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A panel displayed to the side of the [body], often hidden on mobile
devices. Swipes in from right-to-left ([TextDirection.ltr]) or
left-to-right ([TextDirection.rtl])</p><br/>
<p>Typically a [Drawer].</p><br/>
<p>To open the drawer, use the [ScaffoldState.openEndDrawer] function.</p><br/>
<p>To close the drawer, use either [ScaffoldState.closeEndDrawer], [Navigator.pop]
or press the escape key on the keyboard.</p><br/>
<p>{@tool dartpad}
To disable the drawer edge swipe, set the
[Scaffold.endDrawerEnableOpenDragGesture] to false. Then, use
[ScaffoldState.openEndDrawer] to open the drawer and [Navigator.pop] to
close it.</p><br/>
<p>** See code in examples/api/lib/material/scaffold/scaffold.end_drawer.0.dart **
{@end-tool}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="onEndDrawerChanged">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Optional callback that is called when the [Scaffold.endDrawer] is opened or closed.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottomNavigationBar">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A bottom navigation bar to display at the bottom of the scaffold.</p><br/>
<p>Snack bars slide from underneath the bottom navigation bar while bottom
sheets are stacked on top.</p><br/>
<p>The [bottomNavigationBar] is rendered below the [persistentFooterButtons]
and the [body].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottomSheet">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The persistent bottom sheet to display.</p><br/>
<p>A persistent bottom sheet shows information that supplements the primary
content of the app. A persistent bottom sheet remains visible even when
the user interacts with other parts of the app.</p><br/>
<p>A closely related widget is a modal bottom sheet, which is an alternative
to a menu or a dialog and prevents the user from interacting with the rest
of the app. Modal bottom sheets can be created and displayed with the
[showModalBottomSheet] function.</p><br/>
<p>Unlike the persistent bottom sheet displayed by [showBottomSheet]
this bottom sheet is not a [LocalHistoryEntry] and cannot be dismissed
with the scaffold appbar's back button.</p><br/>
<p>If a persistent bottom sheet created with [showBottomSheet] is already
visible, it must be closed before building the Scaffold with a new
[bottomSheet].</p><br/>
<p>The value of [bottomSheet] can be any widget at all. It's unlikely to
actually be a [BottomSheet], which is used by the implementations of
[showBottomSheet] and [showModalBottomSheet]. Typically it's a widget
that includes [Material].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[showBottomSheet], which displays a bottom sheet as a route that can
be dismissed with the scaffold's back button.</li>
<li>[showModalBottomSheet], which displays a modal bottom sheet.</li>
<li>[BottomSheetThemeData], which can be used to customize the default
bottom sheet property values when using a [BottomSheet].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="backgroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color of the [Material] widget that underlies the entire Scaffold.</p><br/>
<p>The theme's [ThemeData.scaffoldBackgroundColor] by default.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="resizeToAvoidBottomInset" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>If true the [body] and the scaffold's floating widgets should size
themselves to avoid the onscreen keyboard whose height is defined by the
ambient [MediaQuery]'s [MediaQueryData.viewInsets] <code>bottom</code> property.</p><br/>
<p>For example, if there is an onscreen keyboard displayed above the
scaffold, the body can be resized to avoid overlapping the keyboard, which
prevents widgets inside the body from being obscured by the keyboard.</p><br/>
<p>Defaults to true.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primary" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether this scaffold is being displayed at the top of the screen.</p><br/>
<p>If true then the height of the [appBar] will be extended by the height
of the screen's status bar, i.e. the top padding for [MediaQuery].</p><br/>
<p>The default value of this property, like the default value of
[AppBar.primary], is true.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="drawerDragStartBehavior" type="DragStartBehaviorAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.DrawerController.dragStartBehavior}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="extendBody" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>If true, and [bottomNavigationBar] or [persistentFooterButtons]
is specified, then the [body] extends to the bottom of the Scaffold,
instead of only extending to the top of the [bottomNavigationBar]
or the [persistentFooterButtons].</p><br/>
<p>If true, a [MediaQuery] widget whose bottom padding matches the height
of the [bottomNavigationBar] will be added above the scaffold's [body].</p><br/>
<p>This property is often useful when the [bottomNavigationBar] has
a non-rectangular shape, like [CircularNotchedRectangle], which
adds a [FloatingActionButton] sized notch to the top edge of the bar.
In this case specifying <code>extendBody: true</code> ensures that scaffold's
body will be visible through the bottom navigation bar's notch.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[extendBodyBehindAppBar], which extends the height of the body
to the top of the scaffold.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="drawerBarrierDismissible" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether the drawer can be dismissed by tapping on the barrier.</p><br/>
<p>If false, and a [drawer] is specified, then the barrier behind the drawer
will not respond to a tap event and thus remains open.</p><br/>
<p>Defaults to true, in which case the drawer will close upon the user tapping on the barrier.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="extendBodyBehindAppBar" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>If true, and an [appBar] is specified, then the height of the [body] is
extended to include the height of the app bar and the top of the body
is aligned with the top of the app bar.</p><br/>
<p>This is useful if the app bar's [AppBar.backgroundColor] is not
completely opaque.</p><br/>
<p>This property is false by default.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[extendBody], which extends the height of the body to the bottom
of the scaffold.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="drawerScrimColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for the scrim that obscures primary content while a drawer is open.</p><br/>
<p>If this is null, then [DrawerThemeData.scrimColor] is used. If that
is also null, then it defaults to [Colors.black54].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottomSheetScrimBuilder">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A builder for the widget that obscures primary content while a bottom sheet is open.</p><br/>
<p>The builder receives the current [BuildContext] and an [Animation] as parameters.
The [Animation] ranges from 0.0 to 1.0 based on how much the bottom sheet covers the screen.
A value of 0.0 represents when the bottom sheet covers 70% of the screen,
and 1.0 represents when the bottom sheet fully covers the screen.</p><br/>
<p>If this is null, then a non-dismissable [ModalBarrier] with [Colors.black] is used. The
barrier is animated to fade in and out as the bottom sheet is opened and closed.</p><br/>
<p>If the builder returns null, then no scrim is shown.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="drawerEdgeDragWidth">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The width of the area within which a horizontal swipe will open the
drawer.</p><br/>
<p>By default, the value used is 20.0 added to the padding edge of
<code>MediaQuery.paddingOf(context)</code> that corresponds to the surrounding
[TextDirection]. This ensures that the drag area for notched devices is
not obscured. For example, if <code>TextDirection.of(context)</code> is set to
[TextDirection.ltr], 20.0 will be added to
<code>MediaQuery.paddingOf(context).left</code>.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="drawerEnableOpenDragGesture" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Determines if the [Scaffold.drawer] can be opened with a drag
gesture on mobile.</p><br/>
<p>On desktop platforms, the drawer is not draggable.</p><br/>
<p>By default, the drag gesture is enabled on mobile.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="endDrawerEnableOpenDragGesture" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Determines if the [Scaffold.endDrawer] can be opened with a
gesture on mobile.</p><br/>
<p>On desktop platforms, the drawer is not draggable.</p><br/>
<p>By default, the drag gesture is enabled on mobile.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="restorationId">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Restoration ID to save and restore the state of the [Scaffold].</p><br/>
<p>If it is non-null, the scaffold will persist and restore whether the
[drawer] and [endDrawer] was open or closed.</p><br/>
<p>The state of this widget is persisted in a [RestorationBucket] claimed
from the surrounding [RestorationScope] using the provided restoration ID.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[RestorationManager], which explains how state restoration works in
Flutter.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="Text">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a text widget.</p><br/>
<p>If the [style] argument is null, the text will use the style from the
closest enclosing [DefaultTextStyle].</p><br/>
<p>The [overflow] property's behavior is affected by the [softWrap] argument.
If the [softWrap] is true or null, the glyph causing overflow, and those
that follow, will not be rendered. Otherwise, it will be shown with the
given overflow option.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="data">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The text to display.</p><br/>
<p>This will be null if a [textSpan] is provided instead.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="style">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>If non-null, the style to use for this text.</p><br/>
<p>If the style's &quot;inherit&quot; property is true, the style will be merged with
the closest enclosing [DefaultTextStyle]. Otherwise, the style will
replace the closest enclosing [DefaultTextStyle].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="strutStyle">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.painting.textPainter.strutStyle}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textAlign" type="TextAlignAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>How the text should be aligned horizontally.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textDirection" type="TextDirectionAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The directionality of the text.</p><br/>
<p>This decides how [textAlign] values like [TextAlign.start] and
[TextAlign.end] are interpreted.</p><br/>
<p>This is also used to disambiguate how to render bidirectional text. For
example, if the [data] is an English phrase followed by a Hebrew phrase,
in a [TextDirection.ltr] context the English phrase will be on the left
and the Hebrew phrase to its right, while in a [TextDirection.rtl]
context, the English phrase will be on the right and the Hebrew phrase on
its left.</p><br/>
<p>Defaults to the ambient [Directionality], if any.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="locale">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Used to select a font when the same Unicode character can
be rendered differently, depending on the locale.</p><br/>
<p>It's rarely necessary to set this property. By default its value
is inherited from the enclosing app with <code>Localizations.localeOf(context)</code>.</p><br/>
<p>See [RenderParagraph.locale] for more information.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="softWrap" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether the text should break at soft line breaks.</p><br/>
<p>If false, the glyphs in the text will be positioned as if there was unlimited horizontal space.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="overflow" type="TextOverflowAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>How visual overflow should be handled.</p><br/>
<p>If this is null [TextStyle.overflow] will be used, otherwise the value
from the nearest [DefaultTextStyle] ancestor will be used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textScaler">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.painting.textPainter.textScaler}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="maxLines">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An optional maximum number of lines for the text to span, wrapping if necessary.
If the text exceeds the given number of lines, it will be truncated according
to [overflow].</p><br/>
<p>If this is 1, text will not wrap. Otherwise, text will be wrapped at the
edge of the box.</p><br/>
<p>If this is null, but there is an ambient [DefaultTextStyle] that specifies
an explicit number for its [DefaultTextStyle.maxLines], then the
[DefaultTextStyle] value will take precedence. You can use a [RichText]
widget directly to entirely override the [DefaultTextStyle].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="semanticsLabel">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.widgets.Text.semanticsLabel}
An alternative semantics label for this text.</p><br/>
<p>If present, the semantics of this widget will contain this value instead
of the actual text. This will overwrite any of the semantics labels applied
directly to the [TextSpan]s.</p><br/>
<p>This is useful for replacing abbreviations or shorthands with the full
text value:</p><br/>
<pre><code class="language-dart">const Text(r'$$', semanticsLabel: 'Double dollars')
</code></pre>
<p>{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="semanticsIdentifier">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A unique identifier for the semantics node for this widget.</p><br/>
<p>This is useful for cases where the text widget needs to have a uniquely
identifiable ID that is recognized through the automation tools without
having a dependency on the actual content of the text that can possibly be
dynamic in nature.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textWidthBasis" type="TextWidthBasisAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.painting.textPainter.textWidthBasis}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textHeightBehavior">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro dart.ui.textHeightBehavior}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="selectionColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use when painting the selection.</p><br/>
<p>This is ignored if [SelectionContainer.maybeOf] returns null
in the [BuildContext] of the [Text] widget.</p><br/>
<p>If null, the ambient [DefaultSelectionStyle] is used (if any); failing
that, the selection color defaults to [DefaultSelectionStyle.defaultColor]
(semi-transparent grey).</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="Text.rich">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a text widget with a [InlineSpan].</p><br/>
<p>The following subclasses of [InlineSpan] may be used to build rich text:</p><br/>
<ul>
<li>[TextSpan]s define text and children [InlineSpan]s.</li>
<li>[WidgetSpan]s define embedded inline widgets.</li>
</ul>
<p>See [RichText] which provides a lower-level way to draw text.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="textSpan">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The text to display as a [InlineSpan].</p><br/>
<p>This will be null if [data] is provided instead.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="key">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Controls how one widget replaces another widget in the tree.</p><br/>
<p>If the [runtimeType] and [key] properties of the two widgets are
[operator==], respectively, then the new widget replaces the old widget by
updating the underlying element (i.e., by calling [Element.update] with the
new widget). Otherwise, the old element is removed from the tree, the new
widget is inflated into an element, and the new element is inserted into the
tree.</p><br/>
<p>In addition, using a [GlobalKey] as the widget's [key] allows the element
to be moved around the tree (changing parent) without losing state. When a
new widget is found (its key and type do not match a previous widget in
the same location), but there was a widget with that same global key
elsewhere in the tree in the previous frame, then that widget's element is
moved to the new location.</p><br/>
<p>Generally, a widget that is the only child of another widget does not need
an explicit key.</p><br/>
<p>See also:</p><br/>
<ul>
<li>The discussions at [Key] and [GlobalKey].</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="style">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>If non-null, the style to use for this text.</p><br/>
<p>If the style's &quot;inherit&quot; property is true, the style will be merged with
the closest enclosing [DefaultTextStyle]. Otherwise, the style will
replace the closest enclosing [DefaultTextStyle].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="strutStyle">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.painting.textPainter.strutStyle}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textAlign" type="TextAlignAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>How the text should be aligned horizontally.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textDirection" type="TextDirectionAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The directionality of the text.</p><br/>
<p>This decides how [textAlign] values like [TextAlign.start] and
[TextAlign.end] are interpreted.</p><br/>
<p>This is also used to disambiguate how to render bidirectional text. For
example, if the [data] is an English phrase followed by a Hebrew phrase,
in a [TextDirection.ltr] context the English phrase will be on the left
and the Hebrew phrase to its right, while in a [TextDirection.rtl]
context, the English phrase will be on the right and the Hebrew phrase on
its left.</p><br/>
<p>Defaults to the ambient [Directionality], if any.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="locale">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Used to select a font when the same Unicode character can
be rendered differently, depending on the locale.</p><br/>
<p>It's rarely necessary to set this property. By default its value
is inherited from the enclosing app with <code>Localizations.localeOf(context)</code>.</p><br/>
<p>See [RenderParagraph.locale] for more information.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="softWrap" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether the text should break at soft line breaks.</p><br/>
<p>If false, the glyphs in the text will be positioned as if there was unlimited horizontal space.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="overflow" type="TextOverflowAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>How visual overflow should be handled.</p><br/>
<p>If this is null [TextStyle.overflow] will be used, otherwise the value
from the nearest [DefaultTextStyle] ancestor will be used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textScaler">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.painting.textPainter.textScaler}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="maxLines">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An optional maximum number of lines for the text to span, wrapping if necessary.
If the text exceeds the given number of lines, it will be truncated according
to [overflow].</p><br/>
<p>If this is 1, text will not wrap. Otherwise, text will be wrapped at the
edge of the box.</p><br/>
<p>If this is null, but there is an ambient [DefaultTextStyle] that specifies
an explicit number for its [DefaultTextStyle.maxLines], then the
[DefaultTextStyle] value will take precedence. You can use a [RichText]
widget directly to entirely override the [DefaultTextStyle].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="semanticsLabel">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@template flutter.widgets.Text.semanticsLabel}
An alternative semantics label for this text.</p><br/>
<p>If present, the semantics of this widget will contain this value instead
of the actual text. This will overwrite any of the semantics labels applied
directly to the [TextSpan]s.</p><br/>
<p>This is useful for replacing abbreviations or shorthands with the full
text value:</p><br/>
<pre><code class="language-dart">const Text(r'$$', semanticsLabel: 'Double dollars')
</code></pre>
<p>{@endtemplate}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="semanticsIdentifier">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A unique identifier for the semantics node for this widget.</p><br/>
<p>This is useful for cases where the text widget needs to have a uniquely
identifiable ID that is recognized through the automation tools without
having a dependency on the actual content of the text that can possibly be
dynamic in nature.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textWidthBasis" type="TextWidthBasisAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.painting.textPainter.textWidthBasis}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textHeightBehavior">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro dart.ui.textHeightBehavior}</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="selectionColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use when painting the selection.</p><br/>
<p>This is ignored if [SelectionContainer.maybeOf] returns null
in the [BuildContext] of the [Text] widget.</p><br/>
<p>If null, the ambient [DefaultSelectionStyle] is used (if any); failing
that, the selection color defaults to [DefaultSelectionStyle.defaultColor]
(semi-transparent grey).</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="TextStyle">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Creates a text style.</p><br/>
<p>The <code>package</code> argument must be non-null if the font family is defined in a
package. It is combined with the <code>fontFamily</code> argument to set the
[fontFamily] property.</p><br/>
<p>On Apple devices the strings 'CupertinoSystemText' and
'CupertinoSystemDisplay' are used in [fontFamily] as proxies for the
Apple system fonts. They currently redirect to the equivalent of SF Pro
Text and SF Pro Display respectively. 'CupertinoSystemText' is designed
for fonts below 20 point size, and 'CupertinoSystemDisplay' is recommended
for sizes 20 and above. When used on non-Apple platforms, these strings
will return the regular fallback font family instead.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="inherit" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Whether null values in this [TextStyle] can be replaced with their value
in another [TextStyle] using [merge].</p><br/>
<p>The [merge] operation is not commutative: the [inherit] value of the
method argument decides whether the two [TextStyle]s can be combined
together. If it is false, the method argument [TextStyle] will be returned.
Otherwise, the combining is allowed, and the returned [TextStyle] inherits
the [inherit] value from the method receiver.</p><br/>
<p>This property does not affect the text style inheritance in an [InlineSpan]
tree: an [InlineSpan]'s text style is merged with that of an ancestor
[InlineSpan] if it has unspecified fields, regardless of its [inherit]
value.</p><br/>
<p>Properties that don't have explicit values or other default values to fall
back to will revert to the defaults: white in color, a font size of 14
pixels, in a sans-serif font face.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[TextStyle.merge], which can be used to combine properties from two
[TextStyle]s.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="color">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use when painting the text.</p><br/>
<p>If [foreground] is specified, this value must be null. The [color] property
is shorthand for <code>Paint()..color = color</code>.</p><br/>
<p>In [merge], [apply], and [lerp], conflicts between [color] and [foreground]
specification are resolved in [foreground]'s favor - i.e. if [foreground] is
specified in one place, it will dominate [color] in another.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="backgroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use as the background for the text.</p><br/>
<p>If [background] is specified, this value must be null. The
[backgroundColor] property is shorthand for
<code>background: Paint()..color = backgroundColor</code>.</p><br/>
<p>In [merge], [apply], and [lerp], conflicts between [backgroundColor] and [background]
specification are resolved in [background]'s favor - i.e. if [background] is
specified in one place, it will dominate [color] in another.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="fontSize">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The size of fonts (in logical pixels) to use when painting the text.</p><br/>
<p>The value specified matches the dimension of the
<a href="https://fonts.google.com/knowledge/glossary/em">em square</a> of the
underlying font, and more often then not isn't exactly the height or the
width of glyphs in the font.</p><br/>
<p>During painting, the [fontSize] is multiplied by the current
<code>textScaleFactor</code> to let users make it easier to read text by increasing
its size.</p><br/>
<p>The [getParagraphStyle] method defaults to 14 logical pixels if [fontSize]
is set to null.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="fontWeight" type="FontWeightAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The typeface thickness to use when painting the text (e.g., bold).</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="fontStyle" type="FontStyleAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The typeface variant to use when drawing the letters (e.g., italics).</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="letterSpacing">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The amount of space (in logical pixels) to add between each letter.
A negative value can be used to bring the letters closer.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="wordSpacing">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The amount of space (in logical pixels) to add at each sequence of
white-space (i.e. between each word). A negative value can be used to
bring the words closer.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textBaseline" type="TextBaselineAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The common baseline that should be aligned between this text span and its
parent text span, or, for the root text spans, with the line box.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="height">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The height of this text span, as a multiple of the font size.</p><br/>
<p>When [height] is [kTextHeightNone], the line height will be determined by
the font's metrics directly, which may differ from the fontSize. Otherwise
the line height of the span of text will be a multiple of [fontSize],
and be exactly <code>fontSize * height</code> logical pixels tall.</p><br/>
<p>For most fonts, setting [height] to 1.0 is not the same as setting height
to [kTextHeightNone] because the [fontSize] sets the height of the EM-square,
which is different than the font provided metrics for line height. The
following diagram illustrates the difference between the font-metrics
defined line height and the line height produced with <code>height: 1.0</code>
(which forms the upper and lower edges of the EM-square):</p><br/>
<p><img src="https://flutter.github.io/assets-for-api-docs/assets/painting/text_height_diagram.png" alt="With the font-metrics-defined line height, there is space between lines appropriate for the font, whereas the EM-square is only the height required to hold most of the characters." /></p><br/>
<p>Examples of the resulting line heights from different values of <code>TextStyle.height</code>:</p><br/>
<p><img src="https://flutter.github.io/assets-for-api-docs/assets/painting/text_height_comparison_diagram.png" alt="Since the explicit line height is applied as a scale factor on the font-metrics-defined line height, the gap above the text grows faster, as the height grows, than the gap below the text." /></p><br/>
<p>See [StrutStyle] and [TextHeightBehavior] for further control of line
height at the paragraph level.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="leadingDistribution" type="TextLeadingDistributionAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>How the vertical space added by the [height] multiplier should be
distributed over and under the text.</p><br/>
<p>When a non-null [height] is specified, after accommodating the glyphs of
the text, the remaining vertical space from the allotted line height will
be distributed over and under the text, according to the
[leadingDistribution] property. See the [TextStyle] class's documentation
for an example.</p><br/>
<p>When [height] is null, [leadingDistribution] does not affect the text
layout.</p><br/>
<p>Defaults to null, which defers to the paragraph's
<code>ParagraphStyle.textHeightBehavior</code>'s [leadingDistribution].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="locale">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The locale used to select region-specific glyphs.</p><br/>
<p>This property is rarely set. Typically the locale used to select
region-specific glyphs is defined by the text widget's [BuildContext]
using <code>Localizations.localeOf(context)</code>. For example [RichText] defines
its locale this way. However, a rich text widget's [TextSpan]s could
specify text styles with different explicit locales in order to select
different region-specific glyphs for each text span.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="foreground">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The paint drawn as a foreground for the text.</p><br/>
<p>The value should ideally be cached and reused each time if multiple text
styles are created with the same paint settings. Otherwise, each time it
will appear like the style changed, which will result in unnecessary
updates all the way through the framework.</p><br/>
<p>If [color] is specified, this value must be null. The [color] property
is shorthand for <code>Paint()..color = color</code>.</p><br/>
<p>In [merge], [apply], and [lerp], conflicts between [color] and [foreground]
specification are resolved in [foreground]'s favor - i.e. if [foreground] is
specified in one place, it will dominate [color] in another.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="background">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The paint drawn as a background for the text.</p><br/>
<p>The value should ideally be cached and reused each time if multiple text
styles are created with the same paint settings. Otherwise, each time it
will appear like the style changed, which will result in unnecessary
updates all the way through the framework.</p><br/>
<p>If [backgroundColor] is specified, this value must be null. The
[backgroundColor] property is shorthand for
<code>background: Paint()..color = backgroundColor</code>.</p><br/>
<p>In [merge], [apply], and [lerp], conflicts between [backgroundColor] and
[background] specification are resolved in [background]'s favor - i.e. if
[background] is specified in one place, it will dominate [backgroundColor]
in another.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shadows">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A list of [Shadow]s that will be painted underneath the text.</p><br/>
<p>Multiple shadows are supported to replicate lighting from multiple light
sources.</p><br/>
<p>Shadows must be in the same order for [TextStyle] to be considered as
equivalent as order produces differing transparency.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="fontFeatures">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A list of [FontFeature]s that affect how the font selects glyphs.</p><br/>
<p>Some fonts support multiple variants of how a given character can be
rendered. For example, a font might provide both proportional and
tabular numbers, or it might offer versions of the zero digit with
and without slashes. [FontFeature]s can be used to select which of
these variants will be used for rendering.</p><br/>
<p>Font features are not interpolated by [lerp].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[fontVariations], for font features that have continuous parameters.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="fontVariations">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A list of [FontVariation]s that affect how a variable font is rendered.</p><br/>
<p>Some fonts are variable fonts that can generate multiple font faces based
on the values of customizable attributes. For example, a variable font
may have a weight axis that can be set to a value between 1 and 1000.
[FontVariation]s can be used to select the values of these design axes.</p><br/>
<p>For example, to control the weight axis of the Roboto Slab variable font
(https://fonts.google.com/specimen/Roboto+Slab):</p><br/>
<pre><code class="language-dart">const TextStyle(
  fontFamily: 'RobotoSlab',
  fontVariations: &lt;FontVariation&gt;[FontVariation('wght', 900.0)]
)
</code></pre>
<p>Font variations can be interpolated via [lerp]. This is fastest when the
same font variation axes are specified, in the same order, in both
[TextStyle] objects. See [lerpFontVariations].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[fontFeatures], for font variations that have discrete values.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="decoration" type="TextDecorationAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The decorations to paint near the text (e.g., an underline).</p><br/>
<p>Multiple decorations can be applied using [TextDecoration.combine].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="decorationColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color in which to paint the text decorations.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="decorationStyle" type="TextDecorationStyleAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The style in which to paint the text decorations (e.g., dashed).</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="decorationThickness">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The thickness of the decoration stroke as a multiplier of the thickness
defined by the font.</p><br/>
<p>The font provides a base stroke width for [decoration]s which scales off
of the [fontSize]. This property may be used to achieve a thinner or
thicker decoration stroke, without changing the [fontSize]. For example,
a [decorationThickness] of 2.0 will draw a decoration twice as thick as
the font defined decoration thickness.</p><br/>
<p>{@tool snippet}
To achieve a bolded strike-through, we can apply a thicker stroke for the
decoration.</p><br/>
<pre><code class="language-dart">const Text(
  'This has a very BOLD strike through!',
  style: TextStyle(
    decoration: TextDecoration.lineThrough,
    decorationThickness: 2.85,
  ),
)
</code></pre>
<p>{@end-tool}</p><br/>
<p>{@tool snippet}
We can apply a very thin and subtle wavy underline (perhaps, when words
are misspelled) by using a [decorationThickness] &lt; 1.0.</p><br/>
<pre><code class="language-dart">const Text(
  'oopsIforgottousespaces!',
  style: TextStyle(
    decoration: TextDecoration.underline,
    decorationStyle: TextDecorationStyle.wavy,
    decorationColor: Colors.red,
    decorationThickness: 0.5,
  ),
)
</code></pre>
<p>{@end-tool}</p><br/>
<p>The default [decorationThickness] is 1.0, which will use the font's base
stroke thickness/width.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="debugLabel">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A human-readable description of this text style.</p><br/>
<p>This property is maintained only in debug builds.</p><br/>
<p>When merging ([merge]), copying ([copyWith]), modifying using [apply], or
interpolating ([lerp]), the label of the resulting style is marked with
the debug labels of the original styles. This helps figuring out where a
particular text style came from.</p><br/>
<p>This property is not considered when comparing text styles using <code>==</code> or
[compareTo], and it does not affect [hashCode].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="fontFamily">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The name of the font to use when painting the text (e.g., Roboto).</p><br/>
<p>If the font is defined in a package, this will be prefixed with
'packages/package_name/' (e.g. 'packages/cool_fonts/Roboto'). The
prefixing is done by the constructor when the <code>package</code> argument is
provided.</p><br/>
<p>The value provided in [fontFamily] will act as the preferred/first font
family that glyphs are looked for in, followed in order by the font families
in [fontFamilyFallback]. When [fontFamily] is null or not provided, the
first value in [fontFamilyFallback] acts as the preferred/first font
family. When neither is provided, then the default platform font will
be used.</p><br/>
<p>When running on Apple devices, the strings 'CupertinoSystemText' and
'CupertinoSystemDisplay' are used as proxies for the Apple system fonts.
They currently redirect to the equivalent of SF Pro Text and SF Pro Display
respectively. 'CupertinoSystemText' is designed for fonts below 20 point
size, and 'CupertinoSystemDisplay' is recommended for sizes 20 and above.
When used on non-Apple platforms, these strings will return the regular
fallback font family instead.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="fontFamilyFallback"/>
                    <xs:attribute name="package"/>
                    <xs:attribute name="overflow" type="TextOverflowAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>How visual text overflow should be handled.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ThemeData">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Create a [ThemeData] that's used to configure a [Theme].</p><br/>
<p>The [colorScheme] and [textTheme] are used by the Material components to
compute default values for visual properties. The API documentation for
each component widget explains exactly how the defaults are computed.</p><br/>
<p>When providing a [ColorScheme], apps can either provide one directly
with the [colorScheme] parameter, or have one generated for them by
using the [colorSchemeSeed] and [brightness] parameters. A generated
color scheme will be based on the tones of [colorSchemeSeed] and all of
its contrasting color will meet accessibility guidelines for readability.
(See [ColorScheme.fromSeed] for more details.)</p><br/>
<p>If the app wants to customize a generated color scheme, it can use
[ColorScheme.fromSeed] directly and then [ColorScheme.copyWith] on the
result to override any colors that need to be replaced. The result of
this can be used as the [colorScheme] directly.</p><br/>
<p>For historical reasons, instead of using a [colorSchemeSeed] or
[colorScheme], you can provide either a [primaryColor] or [primarySwatch]
to construct the [colorScheme], but the results will not be as complete
as when using generation from a seed color.</p><br/>
<p>If [colorSchemeSeed] is non-null then [colorScheme], [primaryColor] and
[primarySwatch] must all be null.</p><br/>
<p>The [textTheme] [TextStyle] colors are black if the color scheme's
brightness is [Brightness.light], and white for [Brightness.dark].</p><br/>
<p>To override the appearance of specific components, provide
a component theme parameter like [sliderTheme], [toggleButtonsTheme],
or [bottomNavigationBarTheme].</p><br/>
<p>When [useSystemColors] is true and the platform supports system colors, then the system colors
will be used to override certain theme colors. The [colorScheme], [textTheme],
[elevatedButtonTheme], [outlinedButtonTheme], [textButtonTheme], [filledButtonTheme], and
[floatingActionButtonTheme] are overriden by the system colors.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[ThemeData.from], which creates a ThemeData from a [ColorScheme].</li>
<li>[ThemeData.light], which creates the default light theme.</li>
<li>[ThemeData.dark], which creates the default dark theme.</li>
<li>[ColorScheme.fromSeed], which is used to create a [ColorScheme] from a seed color.</li>
</ul>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="adaptations"/>
                    <xs:attribute name="applyElevationOverlayColor" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Apply a semi-transparent overlay color on Material surfaces to indicate
elevation for dark themes.</p><br/>
<p>If [useMaterial3] is true, then this flag is ignored as there is a new
[Material.surfaceTintColor] used to create an overlay for Material 3.
This flag is meant only for the Material 2 elevation overlay for dark
themes.</p><br/>
<p>Material drop shadows can be difficult to see in a dark theme, so the
elevation of a surface should be portrayed with an &quot;overlay&quot; in addition
to the shadow. As the elevation of the component increases, the
overlay increases in opacity. [applyElevationOverlayColor] turns the
application of this overlay on or off for dark themes.</p><br/>
<p>If true and [brightness] is [Brightness.dark], a
semi-transparent version of [ColorScheme.onSurface] will be
applied on top of [Material] widgets that have a [ColorScheme.surface]
color. The level of transparency is based on [Material.elevation] as
per the Material Dark theme specification.</p><br/>
<p>If false the surface color will be used unmodified.</p><br/>
<p>Defaults to false in order to maintain backwards compatibility with
apps that were built before the Material Dark theme specification
was published. New apps should set this to true for any themes
where [brightness] is [Brightness.dark].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[Material.elevation], which effects the level of transparency of the
overlay color.</li>
<li>[ElevationOverlay.applyOverlay], which is used by [Material] to apply
the overlay color to its surface color.</li>
<li><a href="https://material.io/design/color/dark-theme.html">https://material.io/design/color/dark-theme.html</a>, which specifies how
the overlay should be applied.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="cupertinoOverrideTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Components of the [CupertinoThemeData] to override from the Material
[ThemeData] adaptation.</p><br/>
<p>By default, [cupertinoOverrideTheme] is null and Cupertino widgets
descendant to the Material [Theme] will adhere to a [CupertinoTheme]
derived from the Material [ThemeData]. e.g. [ThemeData]'s [ColorScheme]
will also inform the [CupertinoThemeData]'s <code>primaryColor</code> etc.</p><br/>
<p>This cascading effect for individual attributes of the [CupertinoThemeData]
can be overridden using attributes of this [cupertinoOverrideTheme].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="extensions">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Arbitrary additions to this theme.</p><br/>
<p>To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
subclasses to [ThemeData.new] or [copyWith].</p><br/>
<p>To obtain an extension, use [extension].</p><br/>
<p>{@tool dartpad}
This sample shows how to create and use a subclass of [ThemeExtension] that
defines two colors.</p><br/>
<p>** See code in examples/api/lib/material/theme/theme_extension.1.dart **
{@end-tool}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[extension], a convenience function for obtaining a specific extension.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="inputDecorationTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The default [InputDecoration] values for [InputDecorator], [TextField],
and [TextFormField] are based on this theme.</p><br/>
<p>See [InputDecoration.applyDefaults].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="materialTapTargetSize" type="MaterialTapTargetSizeAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Configures the hit test size of certain Material widgets.</p><br/>
<p>Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
platforms.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="pageTransitionsTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Default [MaterialPageRoute] transitions per [TargetPlatform].</p><br/>
<p>[MaterialPageRoute.buildTransitions] delegates to a [platform] specific
[PageTransitionsBuilder]. If a matching builder is not found, a builder
whose platform is null is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="platform" type="TargetPlatformAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The platform the material widgets should adapt to target.</p><br/>
<p>Defaults to the current platform, as exposed by [defaultTargetPlatform].
This should be used in order to style UI elements according to platform
conventions.</p><br/>
<p>Widgets from the material library should use this getter (via [Theme.of])
to determine the current platform for the purpose of emulating the
platform behavior (e.g. scrolling or haptic effects). Widgets and render
objects at lower layers that try to emulate the underlying platform
can depend on [defaultTargetPlatform] directly, or may require
that the target platform be provided as an argument. The
[dart:io.Platform] object should only be used directly when it's critical
to actually know the current platform, without any overrides possible (for
example, when a system API is about to be called).</p><br/>
<p>In a test environment, the platform returned is [TargetPlatform.android]
regardless of the host platform. (Android was chosen because the tests
were originally written assuming Android-like behavior, and we added
platform adaptations for other platforms later). Tests can check behavior
for other platforms by setting the [platform] of the [Theme] explicitly to
another [TargetPlatform] value, or by setting
[debugDefaultTargetPlatformOverride].</p><br/>
<p>Determines the defaults for [typography] and [materialTapTargetSize].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="scrollbarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the colors, thickness, and shape of [Scrollbar]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="splashFactory">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Defines the appearance of ink splashes produces by [InkWell]
and [InkResponse].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[InkSplash.splashFactory], which defines the default splash.</li>
<li>[InkRipple.splashFactory], which defines a splash that spreads out
more aggressively than the default.</li>
<li>[InkSparkle.splashFactory], which defines a more aggressive and organic
splash with sparkle effects.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="useMaterial3" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A temporary flag that can be used to opt-out of Material 3 features.</p><br/>
<p>This flag is <em>true</em> by default. If false, then components will
continue to use the colors, typography and other features of
Material 2.</p><br/>
<p>In the long run this flag will be deprecated and eventually
only Material 3 will be supported. We recommend that applications
migrate to Material 3 as soon as that's practical. Until that migration
is complete, this flag can be set to false.</p><br/>
<h2>Defaults</h2>
<p>If a [ThemeData] is <em>constructed</em> with [useMaterial3] set to true, then
some properties will get updated defaults. However, the
[ThemeData.copyWith] method with [useMaterial3] set to true will <em>not</em>
change any of these properties in the resulting [ThemeData].</p><br/>
<style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
<p>| Property        | Material 3 default             | Material 2 default             |
| :-------------- | :----------------------------- | :----------------------------- |
| [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
| [typography]    | [Typography.material2021]      | [Typography.material2014]      |
| [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |</p><br/>
<p>* if the target platform is Android and the app is not
running on the web, otherwise it will fallback to [InkRipple].</p><br/>
<p>If [brightness] is [Brightness.dark] then the default color scheme will
be either the M3 baseline dark color scheme or the M2 baseline dark color
scheme depending on [useMaterial3].</p><br/>
<h2>Affected widgets</h2>
<p>This flag affects styles and components.</p><br/>
<h3>Styles</h3>
<ul>
<li>Color: [ColorScheme], [Material] (see table above)</li>
<li>Shape: (see components below)</li>
<li>Typography: [Typography] (see table above)</li>
</ul>
<h3>Components</h3>
<ul>
<li>Badges: [Badge]</li>
<li>Bottom app bar: [BottomAppBar]</li>
<li>Bottom sheets: [BottomSheet]</li>
<li>Buttons
<ul>
<li>Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]</li>
<li>FAB: [FloatingActionButton], [FloatingActionButton.extended]</li>
<li>Icon buttons: [IconButton], [IconButton.filled] (<em>new</em>), [IconButton.filledTonal], [IconButton.outlined]</li>
<li>Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])</li>
</ul>
</li>
<li>Cards: [Card]</li>
<li>Checkbox: [Checkbox], [CheckboxListTile]</li>
<li>Chips:
<ul>
<li>[ActionChip] (used for Assist and Suggestion chips),</li>
<li>[FilterChip], [ChoiceChip] (used for single selection filter chips),</li>
<li>[InputChip]</li>
</ul>
</li>
<li>Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]</li>
<li>Dialogs: [AlertDialog], [Dialog.fullscreen]</li>
<li>Divider: [Divider], [VerticalDivider]</li>
<li>Lists: [ListTile]</li>
<li>Menus: [MenuAnchor], [DropdownMenu], [MenuBar]</li>
<li>Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])</li>
<li>Navigation drawer: [NavigationDrawer] (replacing [Drawer])</li>
<li>Navigation rail: [NavigationRail]</li>
<li>Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]</li>
<li>Radio button: [Radio], [RadioListTile]</li>
<li>Search: [SearchBar], [SearchAnchor],</li>
<li>Snack bar: [SnackBar]</li>
<li>Slider: [Slider], [RangeSlider]</li>
<li>Switch: [Switch], [SwitchListTile]</li>
<li>Tabs: [TabBar], [TabBar.secondary]</li>
<li>TextFields: [TextField] together with its [InputDecoration]</li>
<li>Time pickers: [showTimePicker], [TimePickerDialog]</li>
<li>Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]</li>
</ul>
<p>In addition, this flag enables features introduced in Android 12.</p><br/>
<ul>
<li>Stretch overscroll: [MaterialScrollBehavior]</li>
<li>Ripple: <code>splashFactory</code> (see table above)</li>
</ul>
<p>See also:</p><br/>
<ul>
<li><a href="https://m3.material.io/">Material 3 specification</a>.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="useSystemColors" type="boolAttributeType"/>
                    <xs:attribute name="visualDensity">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The density value for specifying the compactness of various UI components.</p><br/>
<p>{@template flutter.material.themedata.visualDensity}
Density, in the context of a UI, is the vertical and horizontal
&quot;compactness&quot; of the elements in the UI. It is unitless, since it means
different things to different UI elements. For buttons, it affects the
spacing around the centered label of the button. For lists, it affects the
distance between baselines of entries in the list.</p><br/>
<p>Typically, density values are integral, but any value in range may be
used. The range includes values from [VisualDensity.minimumDensity] (which
is -4), to [VisualDensity.maximumDensity] (which is 4), inclusive, where
negative values indicate a denser, more compact, UI, and positive values
indicate a less dense, more expanded, UI. If a component doesn't support
the value given, it will clamp to the nearest supported value.</p><br/>
<p>The default for visual densities is zero for both vertical and horizontal
densities, which corresponds to the default visual density of components
in the Material Design specification.</p><br/>
<p>As a rule of thumb, a change of 1 or -1 in density corresponds to 4
logical pixels. However, this is not a strict relationship since
components interpret the density values appropriately for their needs.</p><br/>
<p>A larger value translates to a spacing increase (less dense), and a
smaller value translates to a spacing decrease (more dense).</p><br/>
<p>In Material Design 3, the [visualDensity] does not override the default
visual for the following components which are set to [VisualDensity.standard]
for all platforms:</p><br/>
<ul>
<li>[IconButton] - To override the default value of [IconButton.visualDensity],
use [ThemeData.iconButtonTheme] instead.</li>
<li>[Checkbox] - To override the default value of [Checkbox.visualDensity],
use [ThemeData.checkboxTheme] instead.
{@endtemplate}</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="colorScheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.color_scheme.ColorScheme}</p><br/>
<p>This property was added much later than the theme's set of highly specific
colors, like [cardColor], [canvasColor] etc. New components can be defined
exclusively in terms of [colorScheme]. Existing components will gradually
migrate to it, to the extent that is possible without significant
backwards compatibility breaks.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="brightness" type="BrightnessAttributeType"/>
                    <xs:attribute name="colorSchemeSeed"/>
                    <xs:attribute name="canvasColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The default color of [MaterialType.canvas] [Material].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="cardColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color of [Material] when it is used as a [Card].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="disabledColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color used for widgets that are inoperative, regardless of
their state. For example, a disabled checkbox (which may be
checked or unchecked).</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dividerColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color of [Divider]s and [PopupMenuDivider]s, also used
between [ListTile]s, between rows in [DataTable]s, and so forth.</p><br/>
<p>To create an appropriate [BorderSide] that uses this color, consider
[Divider.createBorderSide].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The focus color used indicate that a component has the input focus.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="highlightColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The highlight color used during ink splash animations or to
indicate an item in a menu is selected.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hintColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for hint text or placeholder text, e.g. in
[TextField] fields.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hoverColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The hover color used to indicate when a pointer is hovering over a
component.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The background color for major parts of the app (toolbars, tab bars, etc)</p><br/>
<p>The theme's [colorScheme] property contains [ColorScheme.primary], as
well as a color that contrasts well with the primary color called
[ColorScheme.onPrimary]. It might be simpler to just configure an app's
visuals in terms of the theme's [colorScheme].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryColorDark">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A darker version of the [primaryColor].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryColorLight">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A lighter version of the [primaryColor].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primarySwatch"/>
                    <xs:attribute name="scaffoldBackgroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The default color of the [Material] that underlies the [Scaffold]. The
background color for a typical material app or a page within the app.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="secondaryHeaderColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color of the header of a [PaginatedDataTable] when there are selected rows.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shadowColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color that the [Material] widget uses to draw elevation shadows.</p><br/>
<p>Defaults to fully opaque black.</p><br/>
<p>Shadows can be difficult to see in a dark theme, so the elevation of a
surface should be rendered with an &quot;overlay&quot; in addition to the shadow.
As the elevation of the component increases, the overlay increases in
opacity. The [applyElevationOverlayColor] property turns the elevation
overlay on or off for dark themes.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="splashColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color of ink splashes.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[splashFactory], which defines the appearance of the splash.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="unselectedWidgetColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color used for widgets in their inactive (but enabled)
state. For example, an unchecked checkbox. See also [disabledColor].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="fontFamily"/>
                    <xs:attribute name="fontFamilyFallback"/>
                    <xs:attribute name="package"/>
                    <xs:attribute name="iconTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An icon theme that contrasts with the card and canvas colors.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryIconTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An icon theme that contrasts with the primary color.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryTextTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A text theme that contrasts with the primary color.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Text with a color that contrasts with the card and canvas colors.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="typography">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color and geometry [TextTheme] values used to configure [textTheme].</p><br/>
<p>Defaults to a [platform]-appropriate typography.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="actionIconTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing icons of [BackButtonIcon], [CloseButtonIcon],
[DrawerButtonIcon], or [EndDrawerButtonIcon].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="appBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, elevation, brightness, iconTheme and
textTheme of [AppBar]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="badgeTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color of [Badge]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bannerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color and text style of a [MaterialBanner].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottomAppBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the shape, elevation, and color of a [BottomAppBar].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottomNavigationBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [BottomNavigationBar]
widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottomSheetTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, elevation, and shape of a bottom sheet.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="buttonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Defines the default configuration of button widgets, like [DropdownButton]
and [ButtonBar].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="cardTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The colors and styles used to render [Card].</p><br/>
<p>This is the value returned from [CardTheme.of].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="carouselViewTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [CarouselView] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="checkboxTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [Checkbox] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="chipTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The colors and styles used to render [Chip]s.</p><br/>
<p>This is the value returned from [ChipTheme.of].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dataTableTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [DataTable]
widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="datePickerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [DatePickerDialog]
widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dialogTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the shape of a dialog.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dividerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, thickness, and indents of [Divider]s,
[VerticalDivider]s, etc.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="drawerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [Drawer] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dropdownMenuTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [DropdownMenu] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="elevatedButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and internal layout of
[ElevatedButton]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="expansionTileTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the visual properties of [ExpansionTile]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="filledButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and internal layout of
[FilledButton]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="floatingActionButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the shape, elevation, and color of a
[FloatingActionButton].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="iconButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and internal layout of
[IconButton]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listTileTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance of [ListTile] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="menuBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, shape, elevation, and other [MenuStyle]
aspects of the menu bar created by the [MenuBar] widget.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="menuButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, shape, elevation, and text style of
cascading menu buttons created by [SubmenuButton] or [MenuItemButton].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="menuTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, shape, elevation, and other [MenuStyle]
attributes of menus created by the [SubmenuButton] widget.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="navigationBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the background color, text style, and icon themes
of a [NavigationBar].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="navigationDrawerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the background color, text style, and icon themes
of a [NavigationDrawer].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="navigationRailTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the background color, elevation, text style, and
icon themes of a [NavigationRail].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="outlinedButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and internal layout of
[OutlinedButton]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="popupMenuTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, shape, elevation, and text style of
popup menus.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="progressIndicatorTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [ProgressIndicator] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="radioTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [Radio] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="searchBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [SearchBar] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="searchViewTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of search views created by [SearchAnchor] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="segmentedButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [SegmentedButton] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="sliderTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The colors and shapes used to render [Slider].</p><br/>
<p>This is the value returned from [SliderTheme.of].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="snackBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing colors, shape, elevation, and behavior of a [SnackBar].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="switchTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [Switch] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="tabBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the size, shape, and color of the tab bar indicator.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and internal layout of
[TextButton]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textSelectionTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [TextField] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="timePickerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of time picker widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="toggleButtonsTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Defines the default configuration of [ToggleButtons] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="tooltipTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the visual properties of [Tooltip]s.</p><br/>
<p>This is the value returned from [TooltipTheme.of].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ThemeData.raw">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Create a [ThemeData] given a set of exact values. Most values must be
specified. They all must also be non-null except for
[cupertinoOverrideTheme], and deprecated members.</p><br/>
<p>This will rarely be used directly. It is used by [lerp] to
create intermediate themes based on two themes created with the
[ThemeData] constructor.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="adaptationMap">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A map which contains the adaptations for the theme. The entry's key is the
type of the adaptation; the value is the adaptation itself.</p><br/>
<p>To obtain an adaptation, use [getAdaptation].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="applyElevationOverlayColor" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Apply a semi-transparent overlay color on Material surfaces to indicate
elevation for dark themes.</p><br/>
<p>If [useMaterial3] is true, then this flag is ignored as there is a new
[Material.surfaceTintColor] used to create an overlay for Material 3.
This flag is meant only for the Material 2 elevation overlay for dark
themes.</p><br/>
<p>Material drop shadows can be difficult to see in a dark theme, so the
elevation of a surface should be portrayed with an &quot;overlay&quot; in addition
to the shadow. As the elevation of the component increases, the
overlay increases in opacity. [applyElevationOverlayColor] turns the
application of this overlay on or off for dark themes.</p><br/>
<p>If true and [brightness] is [Brightness.dark], a
semi-transparent version of [ColorScheme.onSurface] will be
applied on top of [Material] widgets that have a [ColorScheme.surface]
color. The level of transparency is based on [Material.elevation] as
per the Material Dark theme specification.</p><br/>
<p>If false the surface color will be used unmodified.</p><br/>
<p>Defaults to false in order to maintain backwards compatibility with
apps that were built before the Material Dark theme specification
was published. New apps should set this to true for any themes
where [brightness] is [Brightness.dark].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[Material.elevation], which effects the level of transparency of the
overlay color.</li>
<li>[ElevationOverlay.applyOverlay], which is used by [Material] to apply
the overlay color to its surface color.</li>
<li><a href="https://material.io/design/color/dark-theme.html">https://material.io/design/color/dark-theme.html</a>, which specifies how
the overlay should be applied.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="cupertinoOverrideTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Components of the [CupertinoThemeData] to override from the Material
[ThemeData] adaptation.</p><br/>
<p>By default, [cupertinoOverrideTheme] is null and Cupertino widgets
descendant to the Material [Theme] will adhere to a [CupertinoTheme]
derived from the Material [ThemeData]. e.g. [ThemeData]'s [ColorScheme]
will also inform the [CupertinoThemeData]'s <code>primaryColor</code> etc.</p><br/>
<p>This cascading effect for individual attributes of the [CupertinoThemeData]
can be overridden using attributes of this [cupertinoOverrideTheme].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="extensions">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Arbitrary additions to this theme.</p><br/>
<p>To define extensions, pass an [Iterable] containing one or more [ThemeExtension]
subclasses to [ThemeData.new] or [copyWith].</p><br/>
<p>To obtain an extension, use [extension].</p><br/>
<p>{@tool dartpad}
This sample shows how to create and use a subclass of [ThemeExtension] that
defines two colors.</p><br/>
<p>** See code in examples/api/lib/material/theme/theme_extension.1.dart **
{@end-tool}</p><br/>
<p>See also:</p><br/>
<ul>
<li>[extension], a convenience function for obtaining a specific extension.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="inputDecorationTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The default [InputDecoration] values for [InputDecorator], [TextField],
and [TextFormField] are based on this theme.</p><br/>
<p>See [InputDecoration.applyDefaults].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="materialTapTargetSize" type="MaterialTapTargetSizeAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Configures the hit test size of certain Material widgets.</p><br/>
<p>Defaults to a [platform]-appropriate size: [MaterialTapTargetSize.padded]
on mobile platforms, [MaterialTapTargetSize.shrinkWrap] on desktop
platforms.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="pageTransitionsTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Default [MaterialPageRoute] transitions per [TargetPlatform].</p><br/>
<p>[MaterialPageRoute.buildTransitions] delegates to a [platform] specific
[PageTransitionsBuilder]. If a matching builder is not found, a builder
whose platform is null is used.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="platform" type="TargetPlatformAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The platform the material widgets should adapt to target.</p><br/>
<p>Defaults to the current platform, as exposed by [defaultTargetPlatform].
This should be used in order to style UI elements according to platform
conventions.</p><br/>
<p>Widgets from the material library should use this getter (via [Theme.of])
to determine the current platform for the purpose of emulating the
platform behavior (e.g. scrolling or haptic effects). Widgets and render
objects at lower layers that try to emulate the underlying platform
can depend on [defaultTargetPlatform] directly, or may require
that the target platform be provided as an argument. The
[dart:io.Platform] object should only be used directly when it's critical
to actually know the current platform, without any overrides possible (for
example, when a system API is about to be called).</p><br/>
<p>In a test environment, the platform returned is [TargetPlatform.android]
regardless of the host platform. (Android was chosen because the tests
were originally written assuming Android-like behavior, and we added
platform adaptations for other platforms later). Tests can check behavior
for other platforms by setting the [platform] of the [Theme] explicitly to
another [TargetPlatform] value, or by setting
[debugDefaultTargetPlatformOverride].</p><br/>
<p>Determines the defaults for [typography] and [materialTapTargetSize].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="scrollbarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the colors, thickness, and shape of [Scrollbar]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="splashFactory">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Defines the appearance of ink splashes produces by [InkWell]
and [InkResponse].</p><br/>
<p>See also:</p><br/>
<ul>
<li>[InkSplash.splashFactory], which defines the default splash.</li>
<li>[InkRipple.splashFactory], which defines a splash that spreads out
more aggressively than the default.</li>
<li>[InkSparkle.splashFactory], which defines a more aggressive and organic
splash with sparkle effects.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="useMaterial3" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A temporary flag that can be used to opt-out of Material 3 features.</p><br/>
<p>This flag is <em>true</em> by default. If false, then components will
continue to use the colors, typography and other features of
Material 2.</p><br/>
<p>In the long run this flag will be deprecated and eventually
only Material 3 will be supported. We recommend that applications
migrate to Material 3 as soon as that's practical. Until that migration
is complete, this flag can be set to false.</p><br/>
<h2>Defaults</h2>
<p>If a [ThemeData] is <em>constructed</em> with [useMaterial3] set to true, then
some properties will get updated defaults. However, the
[ThemeData.copyWith] method with [useMaterial3] set to true will <em>not</em>
change any of these properties in the resulting [ThemeData].</p><br/>
<style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
<p>| Property        | Material 3 default             | Material 2 default             |
| :-------------- | :----------------------------- | :----------------------------- |
| [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
| [typography]    | [Typography.material2021]      | [Typography.material2014]      |
| [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |</p><br/>
<p>* if the target platform is Android and the app is not
running on the web, otherwise it will fallback to [InkRipple].</p><br/>
<p>If [brightness] is [Brightness.dark] then the default color scheme will
be either the M3 baseline dark color scheme or the M2 baseline dark color
scheme depending on [useMaterial3].</p><br/>
<h2>Affected widgets</h2>
<p>This flag affects styles and components.</p><br/>
<h3>Styles</h3>
<ul>
<li>Color: [ColorScheme], [Material] (see table above)</li>
<li>Shape: (see components below)</li>
<li>Typography: [Typography] (see table above)</li>
</ul>
<h3>Components</h3>
<ul>
<li>Badges: [Badge]</li>
<li>Bottom app bar: [BottomAppBar]</li>
<li>Bottom sheets: [BottomSheet]</li>
<li>Buttons
<ul>
<li>Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]</li>
<li>FAB: [FloatingActionButton], [FloatingActionButton.extended]</li>
<li>Icon buttons: [IconButton], [IconButton.filled] (<em>new</em>), [IconButton.filledTonal], [IconButton.outlined]</li>
<li>Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])</li>
</ul>
</li>
<li>Cards: [Card]</li>
<li>Checkbox: [Checkbox], [CheckboxListTile]</li>
<li>Chips:
<ul>
<li>[ActionChip] (used for Assist and Suggestion chips),</li>
<li>[FilterChip], [ChoiceChip] (used for single selection filter chips),</li>
<li>[InputChip]</li>
</ul>
</li>
<li>Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]</li>
<li>Dialogs: [AlertDialog], [Dialog.fullscreen]</li>
<li>Divider: [Divider], [VerticalDivider]</li>
<li>Lists: [ListTile]</li>
<li>Menus: [MenuAnchor], [DropdownMenu], [MenuBar]</li>
<li>Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])</li>
<li>Navigation drawer: [NavigationDrawer] (replacing [Drawer])</li>
<li>Navigation rail: [NavigationRail]</li>
<li>Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]</li>
<li>Radio button: [Radio], [RadioListTile]</li>
<li>Search: [SearchBar], [SearchAnchor],</li>
<li>Snack bar: [SnackBar]</li>
<li>Slider: [Slider], [RangeSlider]</li>
<li>Switch: [Switch], [SwitchListTile]</li>
<li>Tabs: [TabBar], [TabBar.secondary]</li>
<li>TextFields: [TextField] together with its [InputDecoration]</li>
<li>Time pickers: [showTimePicker], [TimePickerDialog]</li>
<li>Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]</li>
</ul>
<p>In addition, this flag enables features introduced in Android 12.</p><br/>
<ul>
<li>Stretch overscroll: [MaterialScrollBehavior]</li>
<li>Ripple: <code>splashFactory</code> (see table above)</li>
</ul>
<p>See also:</p><br/>
<ul>
<li><a href="https://m3.material.io/">Material 3 specification</a>.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="visualDensity">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The density value for specifying the compactness of various UI components.</p><br/>
<p>{@template flutter.material.themedata.visualDensity}
Density, in the context of a UI, is the vertical and horizontal
&quot;compactness&quot; of the elements in the UI. It is unitless, since it means
different things to different UI elements. For buttons, it affects the
spacing around the centered label of the button. For lists, it affects the
distance between baselines of entries in the list.</p><br/>
<p>Typically, density values are integral, but any value in range may be
used. The range includes values from [VisualDensity.minimumDensity] (which
is -4), to [VisualDensity.maximumDensity] (which is 4), inclusive, where
negative values indicate a denser, more compact, UI, and positive values
indicate a less dense, more expanded, UI. If a component doesn't support
the value given, it will clamp to the nearest supported value.</p><br/>
<p>The default for visual densities is zero for both vertical and horizontal
densities, which corresponds to the default visual density of components
in the Material Design specification.</p><br/>
<p>As a rule of thumb, a change of 1 or -1 in density corresponds to 4
logical pixels. However, this is not a strict relationship since
components interpret the density values appropriately for their needs.</p><br/>
<p>A larger value translates to a spacing increase (less dense), and a
smaller value translates to a spacing decrease (more dense).</p><br/>
<p>In Material Design 3, the [visualDensity] does not override the default
visual for the following components which are set to [VisualDensity.standard]
for all platforms:</p><br/>
<ul>
<li>[IconButton] - To override the default value of [IconButton.visualDensity],
use [ThemeData.iconButtonTheme] instead.</li>
<li>[Checkbox] - To override the default value of [Checkbox.visualDensity],
use [ThemeData.checkboxTheme] instead.
{@endtemplate}</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="colorScheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.color_scheme.ColorScheme}</p><br/>
<p>This property was added much later than the theme's set of highly specific
colors, like [cardColor], [canvasColor] etc. New components can be defined
exclusively in terms of [colorScheme]. Existing components will gradually
migrate to it, to the extent that is possible without significant
backwards compatibility breaks.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="canvasColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The default color of [MaterialType.canvas] [Material].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="cardColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color of [Material] when it is used as a [Card].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="disabledColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color used for widgets that are inoperative, regardless of
their state. For example, a disabled checkbox (which may be
checked or unchecked).</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dividerColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color of [Divider]s and [PopupMenuDivider]s, also used
between [ListTile]s, between rows in [DataTable]s, and so forth.</p><br/>
<p>To create an appropriate [BorderSide] that uses this color, consider
[Divider.createBorderSide].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="focusColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The focus color used indicate that a component has the input focus.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="highlightColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The highlight color used during ink splash animations or to
indicate an item in a menu is selected.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hintColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color to use for hint text or placeholder text, e.g. in
[TextField] fields.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="hoverColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The hover color used to indicate when a pointer is hovering over a
component.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The background color for major parts of the app (toolbars, tab bars, etc)</p><br/>
<p>The theme's [colorScheme] property contains [ColorScheme.primary], as
well as a color that contrasts well with the primary color called
[ColorScheme.onPrimary]. It might be simpler to just configure an app's
visuals in terms of the theme's [colorScheme].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryColorDark">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A darker version of the [primaryColor].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryColorLight">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A lighter version of the [primaryColor].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="scaffoldBackgroundColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The default color of the [Material] that underlies the [Scaffold]. The
background color for a typical material app or a page within the app.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="secondaryHeaderColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color of the header of a [PaginatedDataTable] when there are selected rows.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="shadowColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color that the [Material] widget uses to draw elevation shadows.</p><br/>
<p>Defaults to fully opaque black.</p><br/>
<p>Shadows can be difficult to see in a dark theme, so the elevation of a
surface should be rendered with an &quot;overlay&quot; in addition to the shadow.
As the elevation of the component increases, the overlay increases in
opacity. The [applyElevationOverlayColor] property turns the elevation
overlay on or off for dark themes.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="splashColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color of ink splashes.</p><br/>
<p>See also:</p><br/>
<ul>
<li>[splashFactory], which defines the appearance of the splash.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="unselectedWidgetColor">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color used for widgets in their inactive (but enabled)
state. For example, an unchecked checkbox. See also [disabledColor].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="iconTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An icon theme that contrasts with the card and canvas colors.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryIconTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>An icon theme that contrasts with the primary color.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="primaryTextTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A text theme that contrasts with the primary color.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Text with a color that contrasts with the card and canvas colors.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="typography">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The color and geometry [TextTheme] values used to configure [textTheme].</p><br/>
<p>Defaults to a [platform]-appropriate typography.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="actionIconTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing icons of [BackButtonIcon], [CloseButtonIcon],
[DrawerButtonIcon], or [EndDrawerButtonIcon].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="appBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, elevation, brightness, iconTheme and
textTheme of [AppBar]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="badgeTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color of [Badge]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bannerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color and text style of a [MaterialBanner].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottomAppBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the shape, elevation, and color of a [BottomAppBar].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottomNavigationBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [BottomNavigationBar]
widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="bottomSheetTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, elevation, and shape of a bottom sheet.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="buttonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Defines the default configuration of button widgets, like [DropdownButton]
and [ButtonBar].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="cardTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The colors and styles used to render [Card].</p><br/>
<p>This is the value returned from [CardTheme.of].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="carouselViewTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [CarouselView] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="checkboxTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [Checkbox] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="chipTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The colors and styles used to render [Chip]s.</p><br/>
<p>This is the value returned from [ChipTheme.of].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dataTableTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [DataTable]
widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="datePickerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [DatePickerDialog]
widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dialogTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the shape of a dialog.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dividerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, thickness, and indents of [Divider]s,
[VerticalDivider]s, etc.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="drawerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [Drawer] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="dropdownMenuTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [DropdownMenu] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="elevatedButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and internal layout of
[ElevatedButton]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="expansionTileTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the visual properties of [ExpansionTile]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="filledButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and internal layout of
[FilledButton]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="floatingActionButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the shape, elevation, and color of a
[FloatingActionButton].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="iconButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and internal layout of
[IconButton]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listTileTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance of [ListTile] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="menuBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, shape, elevation, and other [MenuStyle]
aspects of the menu bar created by the [MenuBar] widget.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="menuButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, shape, elevation, and text style of
cascading menu buttons created by [SubmenuButton] or [MenuItemButton].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="menuTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, shape, elevation, and other [MenuStyle]
attributes of menus created by the [SubmenuButton] widget.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="navigationBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the background color, text style, and icon themes
of a [NavigationBar].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="navigationDrawerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the background color, text style, and icon themes
of a [NavigationDrawer].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="navigationRailTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the background color, elevation, text style, and
icon themes of a [NavigationRail].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="outlinedButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and internal layout of
[OutlinedButton]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="popupMenuTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the color, shape, elevation, and text style of
popup menus.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="progressIndicatorTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [ProgressIndicator] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="radioTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [Radio] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="searchBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [SearchBar] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="searchViewTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of search views created by [SearchAnchor] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="segmentedButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [SegmentedButton] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="sliderTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>The colors and shapes used to render [Slider].</p><br/>
<p>This is the value returned from [SliderTheme.of].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="snackBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing colors, shape, elevation, and behavior of a [SnackBar].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="switchTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [Switch] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="tabBarTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the size, shape, and color of the tab bar indicator.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textButtonTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and internal layout of
[TextButton]s.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textSelectionTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of [TextField] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="timePickerTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the appearance and layout of time picker widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="toggleButtonsTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Defines the default configuration of [ToggleButtons] widgets.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="tooltipTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A theme for customizing the visual properties of [Tooltip]s.</p><br/>
<p>This is the value returned from [TooltipTheme.of].</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ThemeData.from">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>Create a [ThemeData] based on the colors in the given [colorScheme] and
text styles of the optional [textTheme].</p><br/>
<p>If [colorScheme].brightness is [Brightness.dark] then
[ThemeData.applyElevationOverlayColor] will be set to true to support
the Material dark theme method for indicating elevation by applying
a semi-transparent onSurface color on top of the surface color.</p><br/>
<p>This is the recommended method to theme your application. As we move
forward we will be converting all the widget implementations to only use
colors or colors derived from those in [ColorScheme].</p><br/>
<p>{@tool snippet}
This example will set up an application to use the baseline Material
Design light and dark themes.</p><br/>
<pre><code class="language-dart">MaterialApp(
  theme: ThemeData.from(colorScheme: const ColorScheme.light()),
  darkTheme: ThemeData.from(colorScheme: const ColorScheme.dark()),
)
</code></pre>
<p>{@end-tool}</p><br/>
<p>See <a href="https://material.io/design/color/">https://material.io/design/color/</a> for
more discussion on how to pick the right colors.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="colorScheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>{@macro flutter.material.color_scheme.ColorScheme}</p><br/>
<p>This property was added much later than the theme's set of highly specific
colors, like [cardColor], [canvasColor] etc. New components can be defined
exclusively in terms of [colorScheme]. Existing components will gradually
migrate to it, to the extent that is possible without significant
backwards compatibility breaks.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="textTheme">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>Text with a color that contrasts with the card and canvas colors.</p><br/>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="useMaterial3" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A temporary flag that can be used to opt-out of Material 3 features.</p><br/>
<p>This flag is <em>true</em> by default. If false, then components will
continue to use the colors, typography and other features of
Material 2.</p><br/>
<p>In the long run this flag will be deprecated and eventually
only Material 3 will be supported. We recommend that applications
migrate to Material 3 as soon as that's practical. Until that migration
is complete, this flag can be set to false.</p><br/>
<h2>Defaults</h2>
<p>If a [ThemeData] is <em>constructed</em> with [useMaterial3] set to true, then
some properties will get updated defaults. However, the
[ThemeData.copyWith] method with [useMaterial3] set to true will <em>not</em>
change any of these properties in the resulting [ThemeData].</p><br/>
<style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
<p>| Property        | Material 3 default             | Material 2 default             |
| :-------------- | :----------------------------- | :----------------------------- |
| [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
| [typography]    | [Typography.material2021]      | [Typography.material2014]      |
| [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |</p><br/>
<p>* if the target platform is Android and the app is not
running on the web, otherwise it will fallback to [InkRipple].</p><br/>
<p>If [brightness] is [Brightness.dark] then the default color scheme will
be either the M3 baseline dark color scheme or the M2 baseline dark color
scheme depending on [useMaterial3].</p><br/>
<h2>Affected widgets</h2>
<p>This flag affects styles and components.</p><br/>
<h3>Styles</h3>
<ul>
<li>Color: [ColorScheme], [Material] (see table above)</li>
<li>Shape: (see components below)</li>
<li>Typography: [Typography] (see table above)</li>
</ul>
<h3>Components</h3>
<ul>
<li>Badges: [Badge]</li>
<li>Bottom app bar: [BottomAppBar]</li>
<li>Bottom sheets: [BottomSheet]</li>
<li>Buttons
<ul>
<li>Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]</li>
<li>FAB: [FloatingActionButton], [FloatingActionButton.extended]</li>
<li>Icon buttons: [IconButton], [IconButton.filled] (<em>new</em>), [IconButton.filledTonal], [IconButton.outlined]</li>
<li>Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])</li>
</ul>
</li>
<li>Cards: [Card]</li>
<li>Checkbox: [Checkbox], [CheckboxListTile]</li>
<li>Chips:
<ul>
<li>[ActionChip] (used for Assist and Suggestion chips),</li>
<li>[FilterChip], [ChoiceChip] (used for single selection filter chips),</li>
<li>[InputChip]</li>
</ul>
</li>
<li>Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]</li>
<li>Dialogs: [AlertDialog], [Dialog.fullscreen]</li>
<li>Divider: [Divider], [VerticalDivider]</li>
<li>Lists: [ListTile]</li>
<li>Menus: [MenuAnchor], [DropdownMenu], [MenuBar]</li>
<li>Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])</li>
<li>Navigation drawer: [NavigationDrawer] (replacing [Drawer])</li>
<li>Navigation rail: [NavigationRail]</li>
<li>Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]</li>
<li>Radio button: [Radio], [RadioListTile]</li>
<li>Search: [SearchBar], [SearchAnchor],</li>
<li>Snack bar: [SnackBar]</li>
<li>Slider: [Slider], [RangeSlider]</li>
<li>Switch: [Switch], [SwitchListTile]</li>
<li>Tabs: [TabBar], [TabBar.secondary]</li>
<li>TextFields: [TextField] together with its [InputDecoration]</li>
<li>Time pickers: [showTimePicker], [TimePickerDialog]</li>
<li>Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]</li>
</ul>
<p>In addition, this flag enables features introduced in Android 12.</p><br/>
<ul>
<li>Stretch overscroll: [MaterialScrollBehavior]</li>
<li>Ripple: <code>splashFactory</code> (see table above)</li>
</ul>
<p>See also:</p><br/>
<ul>
<li><a href="https://m3.material.io/">Material 3 specification</a>.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ThemeData.light">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>A default light theme.</p><br/>
<p>This theme does not contain text geometry. Instead, it is expected that
this theme is localized using text geometry using [ThemeData.localize].</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="useMaterial3" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A temporary flag that can be used to opt-out of Material 3 features.</p><br/>
<p>This flag is <em>true</em> by default. If false, then components will
continue to use the colors, typography and other features of
Material 2.</p><br/>
<p>In the long run this flag will be deprecated and eventually
only Material 3 will be supported. We recommend that applications
migrate to Material 3 as soon as that's practical. Until that migration
is complete, this flag can be set to false.</p><br/>
<h2>Defaults</h2>
<p>If a [ThemeData] is <em>constructed</em> with [useMaterial3] set to true, then
some properties will get updated defaults. However, the
[ThemeData.copyWith] method with [useMaterial3] set to true will <em>not</em>
change any of these properties in the resulting [ThemeData].</p><br/>
<style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
<p>| Property        | Material 3 default             | Material 2 default             |
| :-------------- | :----------------------------- | :----------------------------- |
| [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
| [typography]    | [Typography.material2021]      | [Typography.material2014]      |
| [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |</p><br/>
<p>* if the target platform is Android and the app is not
running on the web, otherwise it will fallback to [InkRipple].</p><br/>
<p>If [brightness] is [Brightness.dark] then the default color scheme will
be either the M3 baseline dark color scheme or the M2 baseline dark color
scheme depending on [useMaterial3].</p><br/>
<h2>Affected widgets</h2>
<p>This flag affects styles and components.</p><br/>
<h3>Styles</h3>
<ul>
<li>Color: [ColorScheme], [Material] (see table above)</li>
<li>Shape: (see components below)</li>
<li>Typography: [Typography] (see table above)</li>
</ul>
<h3>Components</h3>
<ul>
<li>Badges: [Badge]</li>
<li>Bottom app bar: [BottomAppBar]</li>
<li>Bottom sheets: [BottomSheet]</li>
<li>Buttons
<ul>
<li>Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]</li>
<li>FAB: [FloatingActionButton], [FloatingActionButton.extended]</li>
<li>Icon buttons: [IconButton], [IconButton.filled] (<em>new</em>), [IconButton.filledTonal], [IconButton.outlined]</li>
<li>Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])</li>
</ul>
</li>
<li>Cards: [Card]</li>
<li>Checkbox: [Checkbox], [CheckboxListTile]</li>
<li>Chips:
<ul>
<li>[ActionChip] (used for Assist and Suggestion chips),</li>
<li>[FilterChip], [ChoiceChip] (used for single selection filter chips),</li>
<li>[InputChip]</li>
</ul>
</li>
<li>Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]</li>
<li>Dialogs: [AlertDialog], [Dialog.fullscreen]</li>
<li>Divider: [Divider], [VerticalDivider]</li>
<li>Lists: [ListTile]</li>
<li>Menus: [MenuAnchor], [DropdownMenu], [MenuBar]</li>
<li>Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])</li>
<li>Navigation drawer: [NavigationDrawer] (replacing [Drawer])</li>
<li>Navigation rail: [NavigationRail]</li>
<li>Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]</li>
<li>Radio button: [Radio], [RadioListTile]</li>
<li>Search: [SearchBar], [SearchAnchor],</li>
<li>Snack bar: [SnackBar]</li>
<li>Slider: [Slider], [RangeSlider]</li>
<li>Switch: [Switch], [SwitchListTile]</li>
<li>Tabs: [TabBar], [TabBar.secondary]</li>
<li>TextFields: [TextField] together with its [InputDecoration]</li>
<li>Time pickers: [showTimePicker], [TimePickerDialog]</li>
<li>Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]</li>
</ul>
<p>In addition, this flag enables features introduced in Android 12.</p><br/>
<ul>
<li>Stretch overscroll: [MaterialScrollBehavior]</li>
<li>Ripple: <code>splashFactory</code> (see table above)</li>
</ul>
<p>See also:</p><br/>
<ul>
<li><a href="https://m3.material.io/">Material 3 specification</a>.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ThemeData.dark">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>A default dark theme.</p><br/>
<p>This theme does not contain text geometry. Instead, it is expected that
this theme is localized using text geometry using [ThemeData.localize].</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="useMaterial3" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A temporary flag that can be used to opt-out of Material 3 features.</p><br/>
<p>This flag is <em>true</em> by default. If false, then components will
continue to use the colors, typography and other features of
Material 2.</p><br/>
<p>In the long run this flag will be deprecated and eventually
only Material 3 will be supported. We recommend that applications
migrate to Material 3 as soon as that's practical. Until that migration
is complete, this flag can be set to false.</p><br/>
<h2>Defaults</h2>
<p>If a [ThemeData] is <em>constructed</em> with [useMaterial3] set to true, then
some properties will get updated defaults. However, the
[ThemeData.copyWith] method with [useMaterial3] set to true will <em>not</em>
change any of these properties in the resulting [ThemeData].</p><br/>
<style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
<p>| Property        | Material 3 default             | Material 2 default             |
| :-------------- | :----------------------------- | :----------------------------- |
| [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
| [typography]    | [Typography.material2021]      | [Typography.material2014]      |
| [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |</p><br/>
<p>* if the target platform is Android and the app is not
running on the web, otherwise it will fallback to [InkRipple].</p><br/>
<p>If [brightness] is [Brightness.dark] then the default color scheme will
be either the M3 baseline dark color scheme or the M2 baseline dark color
scheme depending on [useMaterial3].</p><br/>
<h2>Affected widgets</h2>
<p>This flag affects styles and components.</p><br/>
<h3>Styles</h3>
<ul>
<li>Color: [ColorScheme], [Material] (see table above)</li>
<li>Shape: (see components below)</li>
<li>Typography: [Typography] (see table above)</li>
</ul>
<h3>Components</h3>
<ul>
<li>Badges: [Badge]</li>
<li>Bottom app bar: [BottomAppBar]</li>
<li>Bottom sheets: [BottomSheet]</li>
<li>Buttons
<ul>
<li>Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]</li>
<li>FAB: [FloatingActionButton], [FloatingActionButton.extended]</li>
<li>Icon buttons: [IconButton], [IconButton.filled] (<em>new</em>), [IconButton.filledTonal], [IconButton.outlined]</li>
<li>Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])</li>
</ul>
</li>
<li>Cards: [Card]</li>
<li>Checkbox: [Checkbox], [CheckboxListTile]</li>
<li>Chips:
<ul>
<li>[ActionChip] (used for Assist and Suggestion chips),</li>
<li>[FilterChip], [ChoiceChip] (used for single selection filter chips),</li>
<li>[InputChip]</li>
</ul>
</li>
<li>Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]</li>
<li>Dialogs: [AlertDialog], [Dialog.fullscreen]</li>
<li>Divider: [Divider], [VerticalDivider]</li>
<li>Lists: [ListTile]</li>
<li>Menus: [MenuAnchor], [DropdownMenu], [MenuBar]</li>
<li>Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])</li>
<li>Navigation drawer: [NavigationDrawer] (replacing [Drawer])</li>
<li>Navigation rail: [NavigationRail]</li>
<li>Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]</li>
<li>Radio button: [Radio], [RadioListTile]</li>
<li>Search: [SearchBar], [SearchAnchor],</li>
<li>Snack bar: [SnackBar]</li>
<li>Slider: [Slider], [RangeSlider]</li>
<li>Switch: [Switch], [SwitchListTile]</li>
<li>Tabs: [TabBar], [TabBar.secondary]</li>
<li>TextFields: [TextField] together with its [InputDecoration]</li>
<li>Time pickers: [showTimePicker], [TimePickerDialog]</li>
<li>Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]</li>
</ul>
<p>In addition, this flag enables features introduced in Android 12.</p><br/>
<ul>
<li>Stretch overscroll: [MaterialScrollBehavior]</li>
<li>Ripple: <code>splashFactory</code> (see table above)</li>
</ul>
<p>See also:</p><br/>
<ul>
<li><a href="https://m3.material.io/">Material 3 specification</a>.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>

    <xs:element name="ThemeData.fallback">
        <xs:annotation>
            <xs:documentation xml:lang="en">
<p>The default color theme. Same as [ThemeData.light].</p><br/>
<p>This is used by [Theme.of] when no theme has been specified.</p><br/>
<p>This theme does not contain text geometry. Instead, it is expected that
this theme is localized using text geometry using [ThemeData.localize].</p><br/>
<p>Most applications would use [Theme.of], which provides correct localized
text geometry.</p><br/>

            </xs:documentation>
        </xs:annotation>
        <xs:complexType>
            <xs:complexContent>
                <xs:extension base="objectType">
                    <xs:attribute name="useMaterial3" type="boolAttributeType">
                        <xs:annotation>
                            <xs:documentation xml:lang="en">
<p>A temporary flag that can be used to opt-out of Material 3 features.</p><br/>
<p>This flag is <em>true</em> by default. If false, then components will
continue to use the colors, typography and other features of
Material 2.</p><br/>
<p>In the long run this flag will be deprecated and eventually
only Material 3 will be supported. We recommend that applications
migrate to Material 3 as soon as that's practical. Until that migration
is complete, this flag can be set to false.</p><br/>
<h2>Defaults</h2>
<p>If a [ThemeData] is <em>constructed</em> with [useMaterial3] set to true, then
some properties will get updated defaults. However, the
[ThemeData.copyWith] method with [useMaterial3] set to true will <em>not</em>
change any of these properties in the resulting [ThemeData].</p><br/>
<style>table,td,th { border-collapse: collapse; padding: 0.45em; } td { border: 1px solid }</style>
<p>| Property        | Material 3 default             | Material 2 default             |
| :-------------- | :----------------------------- | :----------------------------- |
| [colorScheme]   | M3 baseline light color scheme | M2 baseline light color scheme |
| [typography]    | [Typography.material2021]      | [Typography.material2014]      |
| [splashFactory] | [InkSparkle]* or [InkRipple]   | [InkSplash]                    |</p><br/>
<p>* if the target platform is Android and the app is not
running on the web, otherwise it will fallback to [InkRipple].</p><br/>
<p>If [brightness] is [Brightness.dark] then the default color scheme will
be either the M3 baseline dark color scheme or the M2 baseline dark color
scheme depending on [useMaterial3].</p><br/>
<h2>Affected widgets</h2>
<p>This flag affects styles and components.</p><br/>
<h3>Styles</h3>
<ul>
<li>Color: [ColorScheme], [Material] (see table above)</li>
<li>Shape: (see components below)</li>
<li>Typography: [Typography] (see table above)</li>
</ul>
<h3>Components</h3>
<ul>
<li>Badges: [Badge]</li>
<li>Bottom app bar: [BottomAppBar]</li>
<li>Bottom sheets: [BottomSheet]</li>
<li>Buttons
<ul>
<li>Common buttons: [ElevatedButton], [FilledButton], [FilledButton.tonal], [OutlinedButton], [TextButton]</li>
<li>FAB: [FloatingActionButton], [FloatingActionButton.extended]</li>
<li>Icon buttons: [IconButton], [IconButton.filled] (<em>new</em>), [IconButton.filledTonal], [IconButton.outlined]</li>
<li>Segmented buttons: [SegmentedButton] (replacing [ToggleButtons])</li>
</ul>
</li>
<li>Cards: [Card]</li>
<li>Checkbox: [Checkbox], [CheckboxListTile]</li>
<li>Chips:
<ul>
<li>[ActionChip] (used for Assist and Suggestion chips),</li>
<li>[FilterChip], [ChoiceChip] (used for single selection filter chips),</li>
<li>[InputChip]</li>
</ul>
</li>
<li>Date pickers: [showDatePicker], [showDateRangePicker], [DatePickerDialog], [DateRangePickerDialog], [InputDatePickerFormField]</li>
<li>Dialogs: [AlertDialog], [Dialog.fullscreen]</li>
<li>Divider: [Divider], [VerticalDivider]</li>
<li>Lists: [ListTile]</li>
<li>Menus: [MenuAnchor], [DropdownMenu], [MenuBar]</li>
<li>Navigation bar: [NavigationBar] (replacing [BottomNavigationBar])</li>
<li>Navigation drawer: [NavigationDrawer] (replacing [Drawer])</li>
<li>Navigation rail: [NavigationRail]</li>
<li>Progress indicators: [CircularProgressIndicator], [LinearProgressIndicator]</li>
<li>Radio button: [Radio], [RadioListTile]</li>
<li>Search: [SearchBar], [SearchAnchor],</li>
<li>Snack bar: [SnackBar]</li>
<li>Slider: [Slider], [RangeSlider]</li>
<li>Switch: [Switch], [SwitchListTile]</li>
<li>Tabs: [TabBar], [TabBar.secondary]</li>
<li>TextFields: [TextField] together with its [InputDecoration]</li>
<li>Time pickers: [showTimePicker], [TimePickerDialog]</li>
<li>Top app bar: [AppBar], [SliverAppBar], [SliverAppBar.medium], [SliverAppBar.large]</li>
</ul>
<p>In addition, this flag enables features introduced in Android 12.</p><br/>
<ul>
<li>Stretch overscroll: [MaterialScrollBehavior]</li>
<li>Ripple: <code>splashFactory</code> (see table above)</li>
</ul>
<p>See also:</p><br/>
<ul>
<li><a href="https://m3.material.io/">Material 3 specification</a>.</li>
</ul>

                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
    </xs:element>


</xs:schema>
