import 'dart:io';

import 'package:analyzer/dart/element/element.dart';
import 'package:markdown/markdown.dart';

import '../utils/cli_log.dart';
import '../utils/config_loader.dart';
import '../utils/utils.dart';


abstract class SpecBuilder {
  final BuilderConfig config;

  SpecBuilder(this.config);

  Future<BuilderResult> build();

  String buildFileComments() {
    final comments = StringBuffer();
    comments.write("// This file was generated by XWidget builder. Do not edit.\n");
    comments.write("// ignore_for_file: camel_case_types\n\n");
    return comments.toString();
  }

  String buildImports(Iterable<LibraryElement?> libraries, [Iterable<String>? configuredImports]) {
    final code = StringBuffer();
    final locations = <String>{}; // used for duplicate checking

    if (libraries.isNotEmpty) {
      // import all libraries used in the spec library
      for (final library in libraries) {
        if (library != null) {
          for (final imported in library.importedLibraries) {
            final location = imported.location.toString();
            if (location != "dart:core" && !locations.contains(location)) {
              locations.add(location);
              code.write("import '$location';\n");
            }
          }
        }
      }
      code.write("\n");
    }

    if (configuredImports != null && configuredImports.isNotEmpty) {
      // write configured imports
      for (final location in configuredImports) {
        if (!locations.contains(location)) {
          code.write("import '$location';\n");
        }
      }
      code.write("\n");
    }

    return code.toString();
  }

  bool isTypeList(String type) {
    final match = RegExp(r"^List(<[_0-9a-zA-z<>?]+>)?\??$").firstMatch(type);
    return match != null;
  }

  String? getParameterDocumentation(ClassElement type, ParameterElement param) {
    var fieldElement = type.getField(param.name);
    if (fieldElement == null && param.isSuperFormal) {
      final superTypes = type.allSupertypes;
      for (final superType in superTypes) {
        fieldElement = superType.element.getField(param.name);
        if (fieldElement != null) break;
      }
    }
    return fieldElement?.documentationComment;
  }

  String getInterfaceElementFQN(InterfaceElement element) {
    return "${element.source.uri.toString()}::${element.name}";
  }

  String? documentationToMarkdown(String? docComment) {
    String? filtered = docComment?.replaceAll(RegExp("///[ ]?"), "");
    filtered = filtered?.replaceAllMapped(
        RegExp(r"\[([a-zA-Z]+)<([a-zA-Z, ]*)>\]"),
        (Match m) => "[${m[1]}&lt;${m[2]}&gt;]"
    );
    if (filtered != null && filtered.isNotEmpty) {
      return markdownToHtml(filtered).replaceAll("</p>", "</p><br/>");
    }
    return null;
  }

  Map<String, dynamic> decodeMetadata(List<ElementAnnotation> metadata) {
    final annotations = <String, dynamic>{};
    for (final elementAnnotation in metadata) {
      final element = elementAnnotation.element;
      if (element is ConstructorElement) {
        final returnElement = element.returnType.element;
        if (returnElement is ClassElement) {
          final annotationName = returnElement.displayName;
          final fieldValues = <String, dynamic>{};
          annotations[annotationName] = fieldValues;
          final constValue = elementAnnotation.computeConstantValue();
          if (constValue != null) {
            for (final field in returnElement.fields) {
              final fieldName = field.displayName;
              final fieldValue = constValue.getField(fieldName);
              if (fieldValue != null && fieldValue.hasKnownValue) {
                final fieldType = fieldValue.type?.getDisplayString(withNullability: false);
                if (fieldType != null) {
                  switch (fieldType) {
                    case "String": fieldValues[fieldName] = fieldValue.toStringValue(); break;
                    case "Int":  fieldValues[fieldName] = fieldValue.toIntValue(); break;
                    case "double":  fieldValues[fieldName] = fieldValue.toDoubleValue(); break;
                    case "bool":  fieldValues[fieldName] = fieldValue.toBoolValue(); break;
                  }
                }
              }
            }
          }
        }
      }
    }
    return annotations;
  }

  /// Check para to see if it should be publicly available
  ///
  /// Private means that it should not appear in the schema as an attribute and it should be a 'private'
  /// reference in Dependencies (prepend '_' to Dependencies key).
  bool isPrivateAccessParam(ParameterElement param, bool isCustomWidget) {
    final paramType = param.type.getDisplayString(withNullability: false);
    return (paramType == "Dependencies" || paramType == "XmlElement") && isCustomWidget;
  }
}

class BuilderResult {
  int warnings = 0;
  int errors = 0;
  List<String> inputs = [];
  List<File> outputs = [];
}

class BuilderConfig {
  final bool allowDeprecated;
  final iconConfig = IconConfig();
  final schemaConfig = SchemaConfig();
  final inflaterConfig = InflaterConfig();
  final controllerConfig = ControllerConfig();

  BuilderConfig({this.allowDeprecated = false});

  Future<void> loadConfig(String path) async {
    final doc = await ConfigLoader.loadYamlDocument(path);
    if (doc != null) {
      CliLog.success("Found config at '$path'");

      // icon config
      iconConfig.target = ConfigLoader.loadToString(doc, "icons.target", iconConfig.target);
      ConfigLoader.loadToSet(doc, "icons.imports", iconConfig.imports);
      ConfigLoader.loadToSet(doc, "icons.sources", iconConfig.sources);

      // controller config
      controllerConfig.target = ConfigLoader.loadToString(doc, "controllers.target", controllerConfig.target);
      ConfigLoader.loadToSet(doc, "controllers.imports", controllerConfig.imports);
      ConfigLoader.loadToSet(doc, "controllers.sources", controllerConfig.sources);

      // schema config
      schemaConfig.target = ConfigLoader.loadToString(doc, "schema.target", schemaConfig.target);
      schemaConfig.template = ConfigLoader.loadToString(doc, "schema.template", schemaConfig.template);
      ConfigLoader.loadToMap(doc, "schema.types", schemaConfig.types);
      ConfigLoader.loadToSet(doc, "schema.attribute_exclusions", schemaConfig.attributeExclusions);

      // inflater config
      inflaterConfig.target = ConfigLoader.loadToString(doc, "inflaters.target", inflaterConfig.target);
      ConfigLoader.loadToSet(doc, "inflaters.imports", inflaterConfig.imports);
      ConfigLoader.loadToSet(doc, "inflaters.sources", inflaterConfig.sources);
      ConfigLoader.loadToSet(doc, "inflaters.includes", inflaterConfig.includes);
      ConfigLoader.loadToSet(doc, "inflaters.constructor_exclusions", inflaterConfig.constructorExclusions);
      ConfigLoader.loadToMap(doc, "inflaters.constructor_arg_defaults", inflaterConfig.constructorArgDefaults);
      ConfigLoader.loadToMap(doc, "inflaters.constructor_arg_parsers", inflaterConfig.constructorArgParsers);
    } else {
      CliLog.warn("Config not found at '$path'");
    }
  }
}

class ControllerConfig {
  String target = "";
  Set<String> imports = {};
  Set<String> sources = {};
  bool isValid() {
    var valid = true;
    if (isBlank(target) && sources.isNotEmpty) {
      CliLog.error("Config missing 'controllers' output target.");
      valid = false;
    }
    return valid;
  }
}

class IconConfig {
  String target = "";
  Set<String> imports = {};
  Set<String> sources = {};

  bool isValid() {
    var valid = true;
    if (isBlank(target) && sources.isNotEmpty) {
      CliLog.error("Config missing 'icons' output target.");
      valid = false;
    }
    return valid;
  }
}

class SchemaConfig with ConfigMixin {
  String target = "";
  String template = "";
  Map<String, String> types = {};
  Set<String> attributeExclusions = {};

  String? findAttributeType(String? dartType) {
    return types[dartType?.replaceAll("?", "")];
  }

  bool isExcludedAttribute(String? type, String? attribute) {
    List<String> keys = _searchKeys(type, attribute);
    for (final key in keys) {
      if (attributeExclusions.contains(key)) return true;
    }
    return false;
  }

  bool isNotExcludedAttribute(String? type, String? attribute) {
    return !isExcludedAttribute(type, attribute);
  }

  bool isValid(InflaterConfig inflaterConfig) {
    var valid = true;
    if (isBlank(target) && inflaterConfig.sources.isNotEmpty) {
      CliLog.error("Config missing 'schema' output target.");
      valid = false;
    }
    if (isBlank(template) && inflaterConfig.sources.isNotEmpty) {
      CliLog.error("Config missing 'schema' template.");
      valid = false;
    }
    return valid;
  }
}

class InflaterConfig with ConfigMixin {
  String target = "";
  Set<String> imports = {};
  Set<String> sources = {};
  Set<String> includes = {};
  Set<String> constructorExclusions = {};
  Map<String, String> constructorArgDefaults = {};
  Map<String, String> constructorArgParsers = {};

  String? findConstructorArgDefault(String? inflaterType, String? argName, [String? defaultValue = null]) {
    List<String> keys = _searchKeys(inflaterType, argName);
    for (final key in keys) {
      final value = constructorArgDefaults[key];
      if (value != null) return value;
    }
    return defaultValue;
  }

  String? findConstructorArgParser(String? inflaterType, String? argName, String? argType) {
    List<String> keys = _searchKeys(inflaterType, argName);
    if (argType != null) {
      keys.add(argType.replaceAll("?", ""));
    }
    for (final key in keys) {
      final parser = constructorArgParsers[key];
      if (parser != null) return parser;
    }
    return null;
  }

  bool isExcludedConstructorArg(String? inflaterType, String? argName) {
    List<String> keys = _searchKeys(inflaterType, argName);
    for (final key in keys) {
      if (constructorExclusions.contains(key)) return true;
    }
    return false;
  }

  bool isNotExcludedConstructorArg(String? inflaterType, String? argName) {
    return !isExcludedConstructorArg(inflaterType, argName);
  }

  bool isValid() {
    var valid = true;
    if (isBlank(target) && sources.isNotEmpty) {
      CliLog.error("Config missing 'inflaters' output target.");
      valid = false;
    }
    return valid;
  }
}

mixin ConfigMixin {
  List<String> _searchKeys(String? inflaterType, String? argName) {
    final keys = <String>[];
    if (inflaterType != null && argName != null) keys.add("$inflaterType:$argName");
    if (inflaterType != null) keys.add("$inflaterType:*");
    if (argName != null) keys.add("*:$argName");
    // no need to add the *.* key since we never want to return the same value for all types and attributes
    return keys;
  }
}